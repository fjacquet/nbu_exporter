---
phase: 02-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/models/Config.go
  - internal/models/Config_test.go
  - internal/exporter/client.go
  - internal/exporter/client_test.go
autonomous: true

must_haves:
  truths:
    - "API key is not visible in error messages or logs (uses MaskAPIKey)"
    - "TLS verification is enabled by default"
    - "Insecure mode requires NBU_INSECURE_MODE=true environment variable"
    - "TLS 1.2 is the minimum supported version"
  artifacts:
    - path: "internal/models/Config.go"
      provides: "TLS enforcement validation"
      contains: "NBU_INSECURE_MODE"
    - path: "internal/exporter/client.go"
      provides: "TLS 1.2 minimum, error-level security warnings"
      contains: "tls.VersionTLS12"
    - path: "internal/models/Config_test.go"
      provides: "Tests for TLS enforcement validation"
      contains: "TestValidate_InsecureSkipVerify"
    - path: "internal/exporter/client_test.go"
      provides: "Tests for TLS configuration"
      contains: "TestNewNbuClient_TLSConfig"
  key_links:
    - from: "internal/models/Config.go"
      to: "Config.Validate()"
      via: "validateTLSConfig method"
      pattern: "validateTLSConfig"
    - from: "internal/exporter/client.go"
      to: "resty.SetTLSClientConfig"
      via: "MinVersion setting"
      pattern: "MinVersion.*tls\\.VersionTLS12"
---

<objective>
Enforce TLS verification by default and protect API key from leaking in logs and error messages.

Purpose: Addresses SEC-01 (secure API key handling) and SEC-02 (TLS enforcement). Prevents sensitive data exposure and ensures secure connections by default.

Output: Updated Config validation requiring explicit opt-in for insecure mode, TLS 1.2 minimum in client, and audited error messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-security-hardening/02-RESEARCH.md

# Source files to modify
@internal/models/Config.go
@internal/exporter/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TLS enforcement validation to Config</name>
  <files>internal/models/Config.go, internal/models/Config_test.go</files>
  <action>
Add TLS configuration validation to Config.Validate() that requires explicit opt-in for insecure mode:

1. Add a new private method `validateTLSConfig()` to Config:
```go
// validateTLSConfig validates TLS security settings.
// InsecureSkipVerify requires explicit opt-in via NBU_INSECURE_MODE environment variable.
func (c *Config) validateTLSConfig() error {
    if c.NbuServer.InsecureSkipVerify {
        insecureAllowed := os.Getenv("NBU_INSECURE_MODE") == "true"
        if !insecureAllowed {
            return fmt.Errorf("TLS verification disabled but NBU_INSECURE_MODE environment variable not set to 'true' - " +
                "set NBU_INSECURE_MODE=true to explicitly allow insecure connections (not recommended for production)")
        }
    }
    return nil
}
```

2. Call `validateTLSConfig()` from `Validate()` after `validateNBUServerConfig()`:
```go
if err := c.validateTLSConfig(); err != nil {
    return err
}
```

3. Add import for "os" package if not present.

4. Add tests in Config_test.go:
- `TestValidate_InsecureSkipVerify_RequiresEnvVar`: Verify error when InsecureSkipVerify=true without env var
- `TestValidate_InsecureSkipVerify_WithEnvVar`: Verify success when NBU_INSECURE_MODE=true is set
- `TestValidate_SecureByDefault`: Verify no error when InsecureSkipVerify=false (default)

Use t.Setenv() in tests to set/unset the environment variable safely.
  </action>
  <verify>
Run tests: `go test ./internal/models/... -v -run TestValidate_Insecure`
Expected: All three test cases pass
  </verify>
  <done>
- InsecureSkipVerify=true without NBU_INSECURE_MODE returns clear error
- InsecureSkipVerify=true with NBU_INSECURE_MODE=true passes validation
- InsecureSkipVerify=false (default) passes validation without env var
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure TLS 1.2 minimum and enhance security logging</name>
  <files>internal/exporter/client.go, internal/exporter/client_test.go</files>
  <action>
Update NewNbuClient() to enforce TLS 1.2 minimum and improve security warnings:

1. Update the TLS configuration in NewNbuClient():
```go
client := resty.New().
    SetTLSClientConfig(&tls.Config{
        InsecureSkipVerify: cfg.NbuServer.InsecureSkipVerify,
        MinVersion:         tls.VersionTLS12, // Enforce TLS 1.2 minimum
    }).
    SetTimeout(defaultTimeout)
```

2. Update the security warning log level from Warn to Error (more visible):
```go
if cfg.NbuServer.InsecureSkipVerify {
    log.Error("SECURITY WARNING: TLS certificate verification disabled - this is insecure for production use")
}
```

3. Add test in client_test.go to verify TLS configuration:
```go
func TestNewNbuClient_TLSConfig(t *testing.T) {
    // Test 1: Verify TLS config is applied
    cfg := testutil.ValidConfig()
    cfg.NbuServer.InsecureSkipVerify = false

    client := NewNbuClient(cfg)
    require.NotNil(t, client)

    // Access underlying http.Client to verify TLS config
    httpClient := client.client.GetClient()
    transport, ok := httpClient.Transport.(*http.Transport)
    if ok && transport.TLSClientConfig != nil {
        assert.Equal(t, uint16(tls.VersionTLS12), transport.TLSClientConfig.MinVersion)
        assert.False(t, transport.TLSClientConfig.InsecureSkipVerify)
    }
}
```

Note: Resty may not expose TLS config directly on transport. If transport is nil, just verify client creation works. The TLS config is applied via SetTLSClientConfig.
  </action>
  <verify>
Run tests: `go test ./internal/exporter/... -v -run TestNewNbuClient`
Run full test suite: `go test ./... -race`
Expected: All tests pass, no race conditions
  </verify>
  <done>
- NewNbuClient sets TLS MinVersion to tls.VersionTLS12
- InsecureSkipVerify=true logs at Error level (not Warn)
- Client creates successfully with both secure and insecure configs
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit and fix API key exposure in error messages</name>
  <files>internal/exporter/client.go</files>
  <action>
Audit FetchData() and other methods to ensure API key is never exposed in error messages or logs:

1. Review error messages in client.go - the API key should NEVER appear in:
   - Error messages returned from FetchData()
   - Log statements
   - Span attributes/events

2. Current state check (grep for potential leaks):
   - `c.cfg.NbuServer.APIKey` should only appear in `getHeaders()` return value
   - Error messages should reference "API key" generically, not the actual value

3. If any leaks found, replace with:
   - Use `c.cfg.MaskAPIKey()` for any logging that needs to show key context
   - Use generic "authentication failed" messages without key details

4. Add a code comment in getHeaders() documenting the security consideration:
```go
// getHeaders returns the standard HTTP headers required for NetBackup API requests.
// SECURITY: The API key is included in the Authorization header. This value should
// never be logged or included in error messages. Use Config.MaskAPIKey() if key
// context is needed for debugging.
func (c *NbuClient) getHeaders() map[string]string {
```

Current audit results (from reading the code):
- getHeaders() returns API key in Authorization header (correct, needed for auth)
- FetchData() error messages include URL and status but NOT the API key (good)
- No other direct API key references in error paths (good)

This task is primarily an audit to VERIFY no leaks exist. Document findings.
  </action>
  <verify>
Run: `grep -n "APIKey" internal/exporter/*.go | grep -v "getHeaders\|MaskAPIKey\|test"`
Expected: Only legitimate uses (getHeaders authorization, MaskAPIKey for logging)

Run: `grep -rn "Authorization.*:" internal/exporter/*.go`
Expected: Only in getHeaders() return map
  </verify>
  <done>
- API key only exposed in Authorization header (required for auth)
- No API key in error messages or log statements
- Security comment added to getHeaders() documenting the responsibility
  </done>
</task>

</tasks>

<verification>
1. TLS enforcement validation: `go test ./internal/models/... -v -run TestValidate`
2. Client TLS configuration: `go test ./internal/exporter/... -v -run TestNewNbuClient`
3. Full test suite with race detection: `go test ./... -race`
4. API key audit: `grep -rn "APIKey" internal/ | grep -v "_test.go" | grep -v "MaskAPIKey\|getHeaders"`
</verification>

<success_criteria>
- [ ] Config.Validate() rejects InsecureSkipVerify=true without NBU_INSECURE_MODE env var
- [ ] Config.Validate() accepts InsecureSkipVerify=true when NBU_INSECURE_MODE=true
- [ ] NewNbuClient configures TLS 1.2 minimum version
- [ ] InsecureSkipVerify warning uses Error log level
- [ ] API key never appears in error messages (audit confirms)
- [ ] All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/02-security-hardening/02-01-SUMMARY.md`
</output>
