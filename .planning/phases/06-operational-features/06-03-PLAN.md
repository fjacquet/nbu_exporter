---
phase: 06-operational-features
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - internal/models/safe_config.go
  - internal/config/watcher.go
  - main.go
  - internal/models/safe_config_test.go
  - internal/config/watcher_test.go
autonomous: true

must_haves:
  truths:
    - "Config changes are applied without restarting the exporter"
    - "SIGHUP signal triggers config reload"
    - "Config file changes trigger automatic reload"
    - "Invalid config does not break running exporter"
    - "Cache is flushed when NBU server address changes"
  artifacts:
    - path: "internal/models/safe_config.go"
      provides: "Thread-safe config wrapper with RWMutex"
      exports: ["SafeConfig", "NewSafeConfig", "ReloadConfig"]
    - path: "internal/config/watcher.go"
      provides: "File watcher and SIGHUP handler"
      exports: ["WatchConfig", "SetupReloadHandler"]
    - path: "main.go"
      provides: "Config reload integration"
      contains: "SafeConfig"
  key_links:
    - from: "main.go"
      to: "internal/models/safe_config.go"
      via: "SafeConfig usage"
      pattern: "SafeConfig"
    - from: "internal/config/watcher.go"
      to: "github.com/fsnotify/fsnotify"
      via: "fsnotify.NewWatcher"
      pattern: "fsnotify\\.NewWatcher"
---

<objective>
Implement dynamic configuration reload via SIGHUP signal and file watching.

Purpose: Operators need to change credentials, server addresses, or other settings without restarting the exporter (avoiding metric gaps). SIGHUP is the standard Unix signal for config reload. File watching provides automatic reload when config is updated by configuration management tools.

Output: SafeConfig wrapper with RWMutex for thread-safe config access, fsnotify file watcher (watching directory, not file), SIGHUP signal handler, cache flush on NBU server change.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-operational-features/06-RESEARCH.md
@.planning/phases/06-operational-features/06-01-SUMMARY.md
@.planning/phases/06-operational-features/06-02-SUMMARY.md
@internal/models/Config.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SafeConfig wrapper with RWMutex</name>
  <files>internal/models/safe_config.go, internal/models/safe_config_test.go</files>
  <action>
1. Add fsnotify dependency:
   ```bash
   go get github.com/fsnotify/fsnotify@v1.9.0
   ```

2. Create internal/models/safe_config.go:

   ```go
   package models

   import (
       "fmt"
       "sync"

       "github.com/fjacquet/nbu_exporter/internal/utils"
       log "github.com/sirupsen/logrus"
   )

   // SafeConfig provides thread-safe access to configuration.
   // It uses RWMutex to allow concurrent reads while serializing writes.
   // Pattern from Prometheus blackbox_exporter.
   type SafeConfig struct {
       mu sync.RWMutex
       C  *Config
   }

   // NewSafeConfig creates a new SafeConfig with the provided initial config.
   func NewSafeConfig(cfg *Config) *SafeConfig {
       return &SafeConfig{
           C: cfg,
       }
   }

   // Get returns the current configuration (read-locked).
   // The returned pointer is safe to use until the next reload.
   func (sc *SafeConfig) Get() *Config {
       sc.mu.RLock()
       defer sc.mu.RUnlock()
       return sc.C
   }

   // ReloadConfig loads and validates a new configuration from the file.
   // Validation happens BEFORE acquiring write lock (fail-fast pattern).
   // Returns error if file cannot be read or validation fails.
   // Returns true if NBU server address changed (signals cache flush needed).
   func (sc *SafeConfig) ReloadConfig(configPath string) (serverChanged bool, err error) {
       // Step 1: Validate config WITHOUT holding any locks
       if !utils.FileExists(configPath) {
           return false, fmt.Errorf("config file not found: %s", configPath)
       }

       var newCfg Config
       if err := utils.ReadFile(&newCfg, configPath); err != nil {
           return false, fmt.Errorf("failed to read config: %w", err)
       }

       if err := newCfg.Validate(); err != nil {
           return false, fmt.Errorf("config validation failed: %w", err)
       }

       // Step 2: Acquire write lock ONLY for pointer swap
       sc.mu.Lock()
       oldHost := sc.C.NbuServer.Host
       oldPort := sc.C.NbuServer.Port
       sc.C = &newCfg
       sc.mu.Unlock()

       // Check if NBU server changed (signals cache flush needed)
       serverChanged = oldHost != newCfg.NbuServer.Host || oldPort != newCfg.NbuServer.Port

       log.Info("Configuration reloaded successfully")
       if serverChanged {
           log.Info("NBU server address changed, cache will be flushed")
       }

       return serverChanged, nil
   }
   ```

3. Create internal/models/safe_config_test.go:

   ```go
   package models

   import (
       "os"
       "path/filepath"
       "sync"
       "testing"
   )

   func TestSafeConfigConcurrentAccess(t *testing.T) {
       cfg := &Config{}
       cfg.Server.Host = "localhost"
       cfg.Server.Port = "2112"
       sc := NewSafeConfig(cfg)

       var wg sync.WaitGroup
       for i := 0; i < 100; i++ {
           wg.Add(1)
           go func() {
               defer wg.Done()
               _ = sc.Get()
           }()
       }
       wg.Wait()
   }

   func TestSafeConfigReloadServerChanged(t *testing.T) {
       // Create temp config file
       tmpDir := t.TempDir()
       configPath := filepath.Join(tmpDir, "config.yaml")

       initialConfig := `
   server:
   host: "localhost"
   port: "2112"
   uri: "/metrics"
   scrapingInterval: "5m"
   nbuserver:
   host: "nbu1.example.com"
   port: "1556"
   scheme: "https"
   apiKey: "test-key"
   `
       os.WriteFile(configPath, []byte(initialConfig), 0644)

       cfg := &Config{}
       cfg.NbuServer.Host = "nbu1.example.com"
       cfg.NbuServer.Port = "1556"
       sc := NewSafeConfig(cfg)

       // Reload with same server - should return false
       changed, err := sc.ReloadConfig(configPath)
       if err != nil {
           t.Fatalf("Reload failed: %v", err)
       }
       if changed {
           t.Error("Expected serverChanged=false for same server")
       }

       // Update config with different server
       newConfig := `
   server:
   host: "localhost"
   port: "2112"
   uri: "/metrics"
   scrapingInterval: "5m"
   nbuserver:
   host: "nbu2.example.com"
   port: "1556"
   scheme: "https"
   apiKey: "test-key"
   `
       os.WriteFile(configPath, []byte(newConfig), 0644)

       changed, err = sc.ReloadConfig(configPath)
       if err != nil {
           t.Fatalf("Reload failed: %v", err)
       }
       if !changed {
           t.Error("Expected serverChanged=true for different server")
       }
   }
   ```

     </action>
     <verify>
       - `go build ./...` succeeds
       - `go test ./internal/models/... -v -race` passes
     </verify>
     <done>SafeConfig exists with Get(), ReloadConfig() returning serverChanged flag</done>
   </task>

<task type="auto">
  <name>Task 2: Create file watcher and SIGHUP handler</name>
  <files>internal/config/watcher.go, internal/config/watcher_test.go</files>
  <action>
1. Create internal/config directory and watcher.go:
   ```go
   package config

import (
"os"
"os/signal"
"path/filepath"
"syscall"

       "github.com/fsnotify/fsnotify"
       log "github.com/sirupsen/logrus"

)

// ReloadFunc is called when config reload is triggered.
// Returns error if reload fails (logged but doesn't stop watcher).
type ReloadFunc func(configPath string) error

// SetupSIGHUPHandler sets up SIGHUP signal handler for config reload.
// Runs in a goroutine, returns immediately.
func SetupSIGHUPHandler(configPath string, reloadFn ReloadFunc) {
// Buffered channel prevents signal loss
sighup := make(chan os.Signal, 1)
signal.Notify(sighup, syscall.SIGHUP)

       go func() {
           for {
               <-sighup
               log.Info("SIGHUP received, reloading configuration...")
               if err := reloadFn(configPath); err != nil {
                   log.Errorf("Configuration reload failed: %v", err)
               }
           }
       }()

       log.Info("SIGHUP handler configured for config reload")

}

// WatchConfigFile watches config file for changes and triggers reload.
// IMPORTANT: Watches directory (not file) for atomic write compatibility.
// Runs in a goroutine, returns watcher for cleanup.
func WatchConfigFile(configPath string, reloadFn ReloadFunc) (\*fsnotify.Watcher, error) {
watcher, err := fsnotify.NewWatcher()
if err != nil {
return nil, err
}

       // Watch directory (not file) - editors use atomic writes
       configDir := filepath.Dir(configPath)
       configName := filepath.Base(configPath)

       if err := watcher.Add(configDir); err != nil {
           watcher.Close()
           return nil, err
       }

       go func() {
           for {
               select {
               case event, ok := <-watcher.Events:
                   if !ok {
                       return
                   }
                   // Filter for our config file and write/create events
                   if filepath.Base(event.Name) == configName {
                       if event.Has(fsnotify.Write) || event.Has(fsnotify.Create) {
                           log.Info("Config file changed, reloading...")
                           if err := reloadFn(configPath); err != nil {
                               log.Errorf("Configuration reload failed: %v", err)
                           }
                       }
                   }
               case err, ok := <-watcher.Errors:
                   if !ok {
                       return
                   }
                   log.Errorf("File watcher error: %v", err)
               }
           }
       }()

       log.Infof("Watching config file: %s", configPath)
       return watcher, nil

}

````

2. Create internal/config/watcher_test.go:
```go
package config

import (
    "os"
    "path/filepath"
    "sync/atomic"
    "testing"
    "time"
)

func TestWatchConfigFile(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, "config.yaml")

    // Create initial config
    os.WriteFile(configPath, []byte("initial"), 0644)

    var reloadCount int32
    reloadFn := func(path string) error {
        atomic.AddInt32(&reloadCount, 1)
        return nil
    }

    watcher, err := WatchConfigFile(configPath, reloadFn)
    if err != nil {
        t.Fatalf("Failed to create watcher: %v", err)
    }
    defer watcher.Close()

    // Give watcher time to start
    time.Sleep(100 * time.Millisecond)

    // Modify config file
    os.WriteFile(configPath, []byte("updated"), 0644)

    // Wait for reload
    time.Sleep(200 * time.Millisecond)

    if atomic.LoadInt32(&reloadCount) == 0 {
        t.Error("Expected reload to be triggered")
    }
}
````

  </action>
  <verify>
    - `go build ./...` succeeds
    - `go test ./internal/config/... -v` passes
  </verify>
  <done>WatchConfigFile and SetupSIGHUPHandler exist, watcher watches directory not file</done>
</task>

<task type="auto">
  <name>Task 3: Integrate config reload into main.go</name>
  <files>main.go</files>
  <action>
1. Update Server struct to use SafeConfig:
   ```go
   type Server struct {
       cfg              *models.SafeConfig       // Thread-safe config wrapper
       configPath       string                   // Path for reload
       httpSrv          *http.Server
       registry         *prometheus.Registry
       telemetryManager *telemetry.Manager
       collector        *exporter.NbuCollector
       configWatcher    *fsnotify.Watcher        // For cleanup
       serverErrChan    chan error
   }
   ```

2. Update NewServer to accept SafeConfig and configPath:

   ```go
   func NewServer(safeCfg *models.SafeConfig, configPath string) *Server {
       cfg := safeCfg.Get()
       // ... existing telemetry setup using cfg ...

       return &Server{
           cfg:              safeCfg,
           configPath:       configPath,
           registry:         prometheus.NewRegistry(),
           telemetryManager: telemetryMgr,
           serverErrChan:    make(chan error, 1),
       }
   }
   ```

3. Add reload method to Server:

   ```go
   // ReloadConfig reloads configuration and flushes cache if needed.
   func (s *Server) ReloadConfig(configPath string) error {
       serverChanged, err := s.cfg.ReloadConfig(configPath)
       if err != nil {
           return err
       }

       // Flush cache if NBU server address changed
       if serverChanged && s.collector != nil {
           if cache := s.collector.GetStorageCache(); cache != nil {
               cache.Flush()
               log.Info("Storage cache flushed due to server address change")
           }
       }

       return nil
   }
   ```

4. Update Start() to use SafeConfig.Get():

   ```go
   func (s *Server) Start() error {
       cfg := s.cfg.Get()
       // ... existing logic using cfg ...
   }
   ```

5. Update main() to set up reload handlers:

   ```go
   func main() {
       rootCmd := &cobra.Command{
           // ... existing setup ...
           RunE: func(cmd *cobra.Command, args []string) error {
               // Validate and load configuration
               cfg, err := validateConfig(configFile)
               if err != nil {
                   return err
               }

               // Wrap in SafeConfig for thread-safe access
               safeCfg := models.NewSafeConfig(cfg)

               // Setup logging
               if err := setupLogging(*safeCfg.Get(), debug); err != nil {
                   return err
               }

               // Create and start server
               server := NewServer(safeCfg, configFile)
               if err := server.Start(); err != nil {
                   return err
               }

               // Setup config reload handlers
               config.SetupSIGHUPHandler(configFile, server.ReloadConfig)
               watcher, err := config.WatchConfigFile(configFile, server.ReloadConfig)
               if err != nil {
                   log.Warnf("File watcher setup failed: %v. SIGHUP reload still available.", err)
               } else {
                   defer watcher.Close()
               }

               // Wait for shutdown
               if err := waitForShutdown(server.ErrorChan()); err != nil {
                   log.Errorf("Server error: %v", err)
               }

               return server.Shutdown()
           },
       }
       // ... rest of main ...
   }
   ```

6. Add import for config package:
   ```go
   import (
       // ... existing imports ...
       "github.com/fjacquet/nbu_exporter/internal/config"
   )
   ```
     </action>
     <verify>
       - `go build ./...` succeeds
       - Start exporter, send SIGHUP: `kill -HUP $(pgrep nbu_exporter)` - logs show reload
       - Modify config file - logs show automatic reload
     </verify>
     <done>Config reload via SIGHUP and file watch working, cache flushed on server change</done>
   </task>

</tasks>

<verification>
1. Build succeeds: `go build ./...`
2. Tests pass: `go test ./... -v`
3. Race detector: `go test -race ./...`
4. SIGHUP test: Start exporter, `kill -HUP <pid>`, verify "Configuration reloaded" in logs
5. File watch test: Edit config.yaml, verify automatic reload in logs
6. Cache flush test: Change nbuserver.host in config, verify "cache flushed" in logs
7. Invalid config test: Set invalid value, verify reload fails but exporter continues
</verification>

<success_criteria>

- SafeConfig wrapper with RWMutex for thread-safe access
- SIGHUP signal triggers config reload
- File watcher (fsnotify) triggers reload on config changes
- Invalid config fails validation without breaking running exporter
- Cache is flushed when NBU server address changes
- All tests pass with race detector
  </success_criteria>

<output>
After completion, create `.planning/phases/06-operational-features/06-03-SUMMARY.md`
</output>
