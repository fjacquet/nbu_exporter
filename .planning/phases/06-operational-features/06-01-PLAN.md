---
phase: 06-operational-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/exporter/cache.go
  - internal/exporter/prometheus.go
  - internal/models/Config.go
  - internal/exporter/cache_test.go
autonomous: true

must_haves:
  truths:
    - "Storage metrics are cached and only refreshed when TTL expires"
    - "Cache TTL is configurable via config.yaml (default 5m)"
    - "Cache hit returns instantly without NBU API call"
    - "Cache miss triggers NBU API call and stores result"
    - "Metric HELP string documents caching behavior"
  artifacts:
    - path: "internal/exporter/cache.go"
      provides: "StorageCache with TTL and last collection timestamp"
      exports: ["StorageCache", "NewStorageCache"]
    - path: "internal/exporter/prometheus.go"
      provides: "NbuCollector with cache integration"
      contains: "storageCache"
    - path: "internal/models/Config.go"
      provides: "Cache TTL configuration"
      contains: "CacheTTL"
  key_links:
    - from: "internal/exporter/prometheus.go"
      to: "internal/exporter/cache.go"
      via: "storageCache field"
      pattern: "storageCache.*StorageCache"
    - from: "internal/exporter/cache.go"
      to: "github.com/patrickmn/go-cache"
      via: "cache.Cache dependency"
      pattern: "cache\\.New"
---

<objective>
Implement TTL-based caching for storage metrics to reduce NetBackup API load.

Purpose: Storage metrics change infrequently (every few minutes) but scrapes happen frequently (every 15-60 seconds). Caching reduces API calls from every scrape to once per TTL interval, reducing load on NetBackup server and improving scrape latency.

Output: StorageCache wrapper using patrickmn/go-cache with configurable TTL, integrated into NbuCollector. Metrics HELP strings document caching per Prometheus best practices.
</objective>

<execution_context>
@~/.claude/agents/gsd-executor.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-operational-features/06-RESEARCH.md
@internal/exporter/prometheus.go
@internal/exporter/netbackup.go
@internal/models/Config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add go-cache dependency and create StorageCache</name>
  <files>internal/exporter/cache.go, go.mod</files>
  <action>
1. Add patrickmn/go-cache dependency:
   ```bash
   go get github.com/patrickmn/go-cache
   ```

2. Create internal/exporter/cache.go with StorageCache:

   ```go
   package exporter

   import (
       "context"
       "sync"
       "time"

       "github.com/patrickmn/go-cache"
   )

   const (
       storageCacheKey = "storage_metrics"
       defaultCacheTTL = 5 * time.Minute
   )

   // StorageCache provides TTL-based caching for storage metrics.
   // It wraps patrickmn/go-cache to cache expensive API calls.
   type StorageCache struct {
       cache              *cache.Cache
       ttl                time.Duration
       lastCollectionTime time.Time
       lastCollectionMu   sync.RWMutex
   }

   // NewStorageCache creates a new cache with the specified TTL.
   // Cleanup interval is set to 2x TTL.
   func NewStorageCache(ttl time.Duration) *StorageCache {
       if ttl <= 0 {
           ttl = defaultCacheTTL
       }
       return &StorageCache{
           cache: cache.New(ttl, ttl*2),
           ttl:   ttl,
       }
   }

   // Get returns cached storage metrics if available.
   // Returns nil, false if cache miss.
   func (sc *StorageCache) Get() ([]StorageMetricValue, bool) {
       if cached, found := sc.cache.Get(storageCacheKey); found {
           return cached.([]StorageMetricValue), true
       }
       return nil, false
   }

   // Set stores storage metrics in the cache with default TTL.
   func (sc *StorageCache) Set(metrics []StorageMetricValue) {
       sc.cache.Set(storageCacheKey, metrics, cache.DefaultExpiration)
       sc.lastCollectionMu.Lock()
       sc.lastCollectionTime = time.Now()
       sc.lastCollectionMu.Unlock()
   }

   // GetLastCollectionTime returns the timestamp of the last successful fetch.
   func (sc *StorageCache) GetLastCollectionTime() time.Time {
       sc.lastCollectionMu.RLock()
       defer sc.lastCollectionMu.RUnlock()
       return sc.lastCollectionTime
   }

   // TTL returns the configured cache TTL.
   func (sc *StorageCache) TTL() time.Duration {
       return sc.ttl
   }

   // Flush clears all cached data. Use on config reload when NBU server changes.
   func (sc *StorageCache) Flush() {
       sc.cache.Flush()
   }
   ```

     </action>
     <verify>
       - `go build ./...` succeeds
       - `go mod tidy` shows go-cache in go.sum
     </verify>
     <done>StorageCache type exists with Get, Set, GetLastCollectionTime, TTL, Flush methods</done>
   </task>

<task type="auto">
  <name>Task 2: Add cache configuration to Config</name>
  <files>internal/models/Config.go</files>
  <action>
1. Add CacheTTL field to Server struct in Config:
   ```go
   Server struct {
       // ... existing fields ...
       CacheTTL string `yaml:"cacheTTL"` // TTL for storage metrics cache (e.g., "5m")
   } `yaml:"server"`
   ```

2. Add SetDefaults() for CacheTTL (in SetDefaults method):

   ```go
   if c.Server.CacheTTL == "" {
       c.Server.CacheTTL = "5m"  // Default 5 minute cache
   }
   ```

3. Add GetCacheTTL helper method:

   ```go
   // GetCacheTTL parses and returns the cache TTL as time.Duration.
   // Returns 5 minutes default if parsing fails.
   func (c *Config) GetCacheTTL() time.Duration {
       duration, err := time.ParseDuration(c.Server.CacheTTL)
       if err != nil {
           return 5 * time.Minute
       }
       return duration
   }
   ```

4. Add validation for CacheTTL in validateServerConfig:
   ```go
   if c.Server.CacheTTL != "" {
       ttl, err := time.ParseDuration(c.Server.CacheTTL)
       if err != nil {
           return fmt.Errorf("invalid cache TTL format '%s': %w (expected format: 5m, 1h, 30s)", c.Server.CacheTTL, err)
       }
       // Warn if TTL >= 5 minutes (Prometheus staleness marker)
       if ttl >= 5*time.Minute {
           log.Warnf("Cache TTL %v >= 5m may cause Prometheus staleness issues", ttl)
       }
   }
   ```
     </action>
     <verify>
       - `go build ./...` succeeds
       - Config validation accepts valid TTL formats
     </verify>
     <done>Config.Server.CacheTTL field exists with validation and GetCacheTTL helper</done>
   </task>

<task type="auto">
  <name>Task 3: Integrate cache with NbuCollector</name>
  <files>internal/exporter/prometheus.go</files>
  <action>
1. Add storageCache field to NbuCollector struct:
   ```go
   type NbuCollector struct {
       cfg                models.Config
       client             *NbuClient
       tracing            *TracerWrapper
       storageCache       *StorageCache  // TTL cache for storage metrics
       // ... existing descriptors ...
   }
   ```

2. Initialize cache in NewNbuCollector:

   ```go
   // Create storage cache with configured TTL
   storageCache := NewStorageCache(cfg.GetCacheTTL())

   return &NbuCollector{
       cfg:          cfg,
       client:       client,
       tracing:      tracing,
       storageCache: storageCache,
       // ... existing fields ...
   }, nil
   ```

3. Update collectStorageMetrics to use cache:

   ```go
   func (c *NbuCollector) collectStorageMetrics(ctx context.Context, span trace.Span) ([]StorageMetricValue, error) {
       // Check cache first
       if metrics, found := c.storageCache.Get(); found {
           log.Debug("Cache hit for storage metrics")
           span.AddEvent("cache_hit", trace.WithAttributes(
               attribute.String("cache_type", "storage"),
           ))
           return metrics, nil
       }

       // Cache miss - fetch from API
       log.Debug("Cache miss for storage metrics, fetching from API")
       span.AddEvent("cache_miss", trace.WithAttributes(
           attribute.String("cache_type", "storage"),
       ))

       metrics, err := FetchStorage(ctx, c.client)
       if err != nil {
           log.Errorf("Failed to fetch storage metrics: %v", err)
           c.recordFetchError(span, "storage_fetch_error", err)
           return nil, err
       }

       // Store in cache
       c.storageCache.Set(metrics)
       return metrics, nil
   }
   ```

4. Update nbuDiskSize descriptor HELP string to document caching:

   ```go
   nbuDiskSize: prometheus.NewDesc(
       "nbu_disk_bytes",
       fmt.Sprintf("The quantity of storage bytes (cached: %s TTL)", cfg.GetCacheTTL()),
       []string{"name", "type", "size"}, nil,
   ),
   ```

5. Add GetStorageCache method for config reload (cache flush):
   ```go
   // GetStorageCache returns the storage cache for management (e.g., flush on config reload).
   func (c *NbuCollector) GetStorageCache() *StorageCache {
       return c.storageCache
   }
   ```
     </action>
     <verify>
       - `go build ./...` succeeds
       - `go test ./internal/exporter/... -v` passes
     </verify>
     <done>NbuCollector uses StorageCache, HELP string documents TTL, cache accessible for flush</done>
   </task>

</tasks>

<verification>
1. Build succeeds: `go build ./...`
2. Tests pass: `go test ./internal/exporter/... -v`
3. Race detector: `go test -race ./internal/exporter/...`
4. Cache test: Create config with cacheTTL: "1m", verify metric HELP shows "(cached: 1m0s TTL)"
</verification>

<success_criteria>

- StorageCache wrapper created with patrickmn/go-cache
- Config.Server.CacheTTL configurable with 5m default
- NbuCollector.collectStorageMetrics checks cache before API call
- Metric HELP string documents caching (per Prometheus guidance)
- Cache can be flushed (for config reload)
- All tests pass with race detector
  </success_criteria>

<output>
After completion, create `.planning/phases/06-operational-features/06-01-SUMMARY.md`
</output>
