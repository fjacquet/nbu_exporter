---
phase: 04-test-coverage
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/exporter/concurrent_test.go
  - internal/exporter/client_test.go
autonomous: true

must_haves:
  truths:
    - "Concurrent collector access is tested with race detector"
    - "Client handles network timeouts correctly"
    - "Client handles unusual HTTP responses correctly"
    - "No race conditions detected in concurrent tests"
  artifacts:
    - path: "internal/exporter/concurrent_test.go"
      provides: "Concurrent access tests for collector"
      min_lines: 100
    - path: "internal/exporter/client_test.go"
      provides: "Client error handling edge case tests"
  key_links:
    - from: "internal/exporter/concurrent_test.go"
      to: "internal/exporter/prometheus.go"
      via: "NbuCollector.Collect concurrent calls"
      pattern: "Collect.*chan.*prometheus.Metric"
    - from: "internal/exporter/client_test.go"
      to: "internal/exporter/client.go"
      via: "error handling paths"
      pattern: "context.DeadlineExceeded|timeout"
---

<objective>
Add concurrent collector access tests and client error handling edge case tests.

Purpose: Addresses TEST-04 (concurrent tests) and TEST-05 (client edge cases) requirements. These tests ensure thread-safety of the collector under concurrent scrapes and verify client behavior under adverse network conditions.

Output: New concurrent_test.go file and expanded client_test.go
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-test-coverage/04-RESEARCH.md
@internal/exporter/prometheus.go
@internal/exporter/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create concurrent collector access tests</name>
  <files>internal/exporter/concurrent_test.go</files>
  <action>
Create new file concurrent_test.go with tests for concurrent collector access.

File content:

```go
package exporter

import (
    "sync"
    "testing"

    "github.com/fjacquet/nbu_exporter/internal/models"
    "github.com/fjacquet/nbu_exporter/internal/testutil"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/stretchr/testify/require"
)

// TestCollectorConcurrentCollect verifies that multiple goroutines can
// safely call Collect() simultaneously without race conditions.
// Run with: go test -race -v -run TestCollectorConcurrentCollect
func TestCollectorConcurrentCollect(t *testing.T) {
    // Create mock server with standard responses
    server := testutil.NewMockServer().
        WithTLS().
        WithJobsEndpoint(models.APIVersion130, createTestJobsResponse()).
        WithStorageEndpoint(models.APIVersion130, createTestStorageResponse()).
        Build()
    defer server.Close()

    // Create collector
    cfg := createTestConfig(server.URL, models.APIVersion130)
    collector, err := NewNbuCollector(cfg)
    require.NoError(t, err)
    defer collector.Close()

    const numGoroutines = 10
    var wg sync.WaitGroup

    // Launch multiple concurrent Collect calls
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            ch := make(chan prometheus.Metric, 100)
            go func() {
                collector.Collect(ch)
                close(ch)
            }()

            // Drain channel to ensure Collect completes
            count := 0
            for range ch {
                count++
            }

            // Should receive at least some metrics
            if count == 0 {
                t.Logf("Goroutine %d: collected 0 metrics", id)
            }
        }(i)
    }

    wg.Wait()
}

// TestCollectorConcurrentDescribe verifies Describe() is safe for concurrent calls
func TestCollectorConcurrentDescribe(t *testing.T) {
    server := testutil.NewMockServer().
        WithTLS().
        WithJobsEndpoint(models.APIVersion130, createTestJobsResponse()).
        WithStorageEndpoint(models.APIVersion130, createTestStorageResponse()).
        Build()
    defer server.Close()

    cfg := createTestConfig(server.URL, models.APIVersion130)
    collector, err := NewNbuCollector(cfg)
    require.NoError(t, err)
    defer collector.Close()

    const numGoroutines = 10
    var wg sync.WaitGroup

    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()

            ch := make(chan *prometheus.Desc, 100)
            go func() {
                collector.Describe(ch)
                close(ch)
            }()

            // Drain channel
            for range ch {
            }
        }()
    }

    wg.Wait()
}

// TestCollectorCollectDuringClose verifies graceful handling when
// Close() is called during Collect()
func TestCollectorCollectDuringClose(t *testing.T) {
    server := testutil.NewMockServer().
        WithTLS().
        WithJobsEndpoint(models.APIVersion130, createTestJobsResponse()).
        WithStorageEndpoint(models.APIVersion130, createTestStorageResponse()).
        Build()
    defer server.Close()

    cfg := createTestConfig(server.URL, models.APIVersion130)
    collector, err := NewNbuCollector(cfg)
    require.NoError(t, err)

    var wg sync.WaitGroup

    // Start a Collect in background
    wg.Add(1)
    go func() {
        defer wg.Done()
        ch := make(chan prometheus.Metric, 100)
        collector.Collect(ch)
        close(ch)
        for range ch {
        }
    }()

    // Call Close() while Collect may be running
    // This tests graceful shutdown during active collection
    err = collector.Close()
    // Close should succeed (or return error if already closing)
    if err != nil {
        t.Logf("Close() during Collect returned: %v", err)
    }

    wg.Wait()
}
```

Use existing helper functions from test files (createTestConfig, createTestJobsResponse, createTestStorageResponse). If these don't exist in a shared location, add minimal versions to the test file.
  </action>
  <verify>
Run concurrent tests with race detector:
```bash
go test -race -v ./internal/exporter/... -run TestCollectorConcurrent -count=3
```
Verify no race conditions detected.
  </verify>
  <done>concurrent_test.go created with 3 test functions, all pass with -race flag</done>
</task>

<task type="auto">
  <name>Task 2: Add client error handling edge case tests</name>
  <files>internal/exporter/client_test.go</files>
  <action>
Add edge case tests for client error handling to client_test.go.

Add new test functions:

1. **TestClientNetworkTimeout**: Test behavior when server doesn't respond
   - Create server that delays response longer than client timeout
   - Use httptest.NewServer with handler that does time.Sleep(10 * time.Second)
   - Create client with short timeout (100ms)
   - Call FetchStorage or similar
   - Verify error contains "timeout" or "deadline exceeded"

2. **TestClientConnectionRefused**: Test behavior when server is unreachable
   - Create config with non-existent server (e.g., localhost:65535)
   - Attempt to make request
   - Verify error indicates connection failure

3. **TestClientEmptyResponse**: Test handling of empty response body
   - Create server that returns 200 OK with empty body
   - Call fetch method
   - Verify error indicates empty/invalid response

4. **TestClientMalformedJSON**: Test handling of invalid JSON response
   - Create server that returns 200 OK with "not valid json"
   - Call fetch method
   - Verify error indicates JSON parsing failure

5. **TestClientPartialResponse**: Test handling of truncated response
   - Create server that returns incomplete JSON (e.g., "{\"data\":")
   - Call fetch method
   - Verify error handling for incomplete data

6. **TestClientHTTPErrors**: Table-driven test for various HTTP status codes
   - 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found
   - 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable
   - Verify appropriate error returned for each

Use existing test patterns and helpers from client_test.go. Focus on error paths that may not have coverage.
  </action>
  <verify>
Run client tests with coverage:
```bash
go test -race -v -cover ./internal/exporter/... -run TestClient -count=1 2>&1 | tail -30
```
Verify error handling tests pass.
  </verify>
  <done>Client edge case tests added, all tests pass with -race flag</done>
</task>

<task type="auto">
  <name>Task 3: Verify race detector passes for all exporter tests</name>
  <files>internal/exporter/concurrent_test.go</files>
  <action>
Run the full exporter test suite with race detector multiple times to verify no race conditions.

Steps:
1. Run all exporter tests with -race flag 3 times:
   ```bash
   go test -race ./internal/exporter/... -count=3
   ```

2. If any race conditions are detected:
   - Analyze the race report
   - Fix the issue in concurrent_test.go or note if it's in production code (existing issue)

3. Verify coverage for exporter package remains at or above 88.1%:
   ```bash
   go test -cover ./internal/exporter/...
   ```

4. If concurrent tests cause excessive test duration, consider:
   - Reducing numGoroutines from 10 to 5
   - Adding t.Parallel() only where safe
   - Disabling retries in client for test mode (if not already done)

The tests should complete within 60 seconds total for the exporter package.
  </action>
  <verify>
Run full exporter test suite:
```bash
time go test -race -v ./internal/exporter/... -count=1 2>&1 | tail -20
```
Verify:
- No race conditions detected
- Coverage >= 88.1%
- Tests complete in under 60 seconds
  </verify>
  <done>All exporter tests pass with race detector, no races detected, coverage maintained</done>
</task>

</tasks>

<verification>
1. Concurrent tests exist: `ls internal/exporter/concurrent_test.go`
2. All tests pass with race detector: `go test -race ./internal/exporter/... -count=3`
3. No race conditions detected in output
4. Client edge case tests cover error scenarios
5. Exporter coverage maintained at 88%+
</verification>

<success_criteria>
- concurrent_test.go exists with TestCollectorConcurrentCollect, TestCollectorConcurrentDescribe, TestCollectorCollectDuringClose
- Client error handling tests added to client_test.go
- All tests pass with `go test -race ./internal/exporter/...`
- No race conditions detected in 3 consecutive runs
- Tests complete within reasonable time (< 60 seconds)
</success_criteria>

<output>
After completion, create `.planning/phases/04-test-coverage/04-04-SUMMARY.md`
</output>
