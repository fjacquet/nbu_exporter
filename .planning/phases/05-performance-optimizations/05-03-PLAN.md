---
phase: 05-performance-optimizations
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/exporter/netbackup.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Maps in FetchAllJobs are pre-allocated with capacity hints"
    - "Result slices are pre-allocated based on map sizes"
    - "No functional changes to metrics collection"
  artifacts:
    - path: "internal/exporter/netbackup.go"
      provides: "Pre-allocated collections"
      contains: "make.*map.*JobMetricKey.*100"
  key_links:
    - from: "FetchAllJobs"
      to: "sizeMap/countMap/statusMap"
      via: "make with capacity"
      pattern: "make\\(map\\[.*\\]float64,\\s*\\d+"
---

<objective>
Add pre-allocation capacity hints to reduce memory allocations during job fetching

Purpose: When processing many jobs, maps and slices grow dynamically, causing multiple reallocations. By pre-allocating with reasonable capacity hints, we reduce GC pressure and improve performance. This is a minor optimization (5-10% improvement) but completes the performance optimization suite.

Output: FetchAllJobs with pre-allocated maps and slices based on typical workload sizes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-performance-optimizations/05-RESEARCH.md
@.planning/phases/05-performance-optimizations/05-01-SUMMARY.md
@internal/exporter/netbackup.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Constants for Expected Capacities</name>
  <files>internal/exporter/netbackup.go</files>
  <action>
  Add constants documenting expected capacity assumptions:

  ```go
  const (
      // ... existing constants ...

      // Pre-allocation capacity hints for job metrics
      // Typical environments have 20-100 unique job type/policy/status combinations
      expectedJobMetricKeys   = 100
      expectedStatusMetricKeys = 50
  )
  ```

  These values are based on typical NetBackup environments:
  - Job types: ~5-10 (BACKUP, RESTORE, VERIFY, etc.)
  - Policy types: ~5-20
  - Status codes: ~10-20 common values
  - Combinations: Usually 20-100 unique keys

  The pre-allocation is intentionally generous to avoid reallocations in most cases.
  </action>
  <verify>
  ```bash
  grep -n "expectedJobMetricKeys\|expectedStatusMetricKeys" internal/exporter/netbackup.go
  ```
  Both constants should be defined.
  </verify>
  <done>Capacity hint constants added with documentation</done>
</task>

<task type="auto">
  <name>Task 2: Pre-allocate Maps and Slices in FetchAllJobs</name>
  <files>internal/exporter/netbackup.go</files>
  <action>
  Update FetchAllJobs to use capacity hints:

  1. Pre-allocate aggregation maps:
     ```go
     // Use typed maps for aggregation with pre-allocated capacity
     sizeMap := make(map[JobMetricKey]float64, expectedJobMetricKeys)
     countMap := make(map[JobMetricKey]float64, expectedJobMetricKeys)
     statusMap := make(map[JobStatusKey]float64, expectedStatusMetricKeys)
     ```

  2. Pre-allocate result slices based on actual map sizes (after pagination completes):
     ```go
     // Convert maps to typed slices with pre-allocated capacity
     jobsSize = make([]JobMetricValue, 0, len(sizeMap))
     jobsCount = make([]JobMetricValue, 0, len(countMap))
     statusCount = make([]JobStatusMetricValue, 0, len(statusMap))

     for key, value := range sizeMap {
         jobsSize = append(jobsSize, JobMetricValue{Key: key, Value: value})
     }
     for key, value := range countMap {
         jobsCount = append(jobsCount, JobMetricValue{Key: key, Value: value})
     }
     for key, value := range statusMap {
         statusCount = append(statusCount, JobStatusMetricValue{Key: key, Value: value})
     }
     ```

  Key points:
  - Map pre-allocation uses fixed hints (unknown actual count until complete)
  - Slice pre-allocation uses exact map size (known at conversion time)
  - No functional changes - just capacity hints
  </action>
  <verify>
  ```bash
  go test ./internal/exporter/... -run "FetchAllJobs\|Job" -v
  ```
  All job-related tests should pass (no functional changes).
  </verify>
  <done>Maps and slices pre-allocated with capacity hints</done>
</task>

<task type="auto">
  <name>Task 3: Run Full Test Suite and Verify No Regressions</name>
  <files>internal/exporter/netbackup.go</files>
  <action>
  1. Run full test suite with race detector:
     ```bash
     go test -race ./...
     ```

  2. Verify build succeeds:
     ```bash
     go build ./...
     ```

  3. Optionally run benchmarks if they exist:
     ```bash
     go test -bench=. ./internal/exporter/... 2>/dev/null || echo "No benchmarks"
     ```

  Note: This is a pure optimization with no functional changes. All existing tests should pass unchanged.
  </action>
  <verify>
  ```bash
  go test -race ./... && go build ./...
  ```
  All tests pass, build succeeds.
  </verify>
  <done>All tests pass, build succeeds, pre-allocation complete</done>
</task>

</tasks>

<verification>
- [ ] expectedJobMetricKeys and expectedStatusMetricKeys constants defined
- [ ] sizeMap, countMap, statusMap use capacity hints in make()
- [ ] Result slices use len(map) for pre-allocation
- [ ] All existing tests pass (no regressions)
- [ ] Race detector passes
- [ ] Build succeeds
</verification>

<success_criteria>
1. Pre-allocated maps: All aggregation maps use capacity hints
2. Pre-allocated slices: Result slices use exact capacity from map sizes
3. No functional changes: Same behavior, same output
4. All tests pass: Existing tests pass unchanged
5. Documented: Constants explain capacity assumptions
</success_criteria>

<output>
After completion, create `.planning/phases/05-performance-optimizations/05-03-SUMMARY.md`
</output>
