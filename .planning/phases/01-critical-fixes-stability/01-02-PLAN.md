---
phase: 01-critical-fixes-stability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/models/Config.go
  - internal/models/Config_test.go
autonomous: true

must_haves:
  truths:
    - "Invalid URLs in configuration are caught during Validate() with clear error messages"
    - "BuildURL() returns error instead of silently failing on invalid base URL"
    - "Config validation fails fast on malformed NBU server settings"
  artifacts:
    - path: "internal/models/Config.go"
      provides: "URL validation in config validation"
      contains: "validateNBUBaseURL"
    - path: "internal/models/Config_test.go"
      provides: "Tests for URL validation"
      contains: "TestConfig.*InvalidURL"
  key_links:
    - from: "internal/models/Config.go"
      to: "Validate()"
      via: "validateNBUBaseURL called during validation"
      pattern: "validateNBUBaseURL\\(\\)"
---

<objective>
Add URL validation to configuration to catch invalid URLs at startup

Purpose: Fix FRAG-03 (URL parsing errors silently ignored in BuildURL). Currently line 332 calls `url.Parse()` and ignores the error with `u, _ := url.Parse(...)`. Invalid URLs are silently lost, causing confusing downstream failures. By validating URLs during config validation, we catch these errors early with clear messages.

Output: Config validation that rejects malformed URLs at startup, BuildURL that handles errors properly
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/models/Config.go
@internal/models/Config_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add URL validation to Config.Validate()</name>
  <files>internal/models/Config.go</files>
  <action>
Add URL validation during config validation:

1. Add a new validation function `validateNBUBaseURL()`:

   ```go
   // validateNBUBaseURL validates that the NBU server configuration produces a valid URL.
   // This catches malformed host, scheme, or port values early during startup.
   func (c *Config) validateNBUBaseURL() error {
       baseURL := c.GetNBUBaseURL()
       parsedURL, err := url.Parse(baseURL)
       if err != nil {
           return fmt.Errorf("invalid NBU server URL '%s': %w", baseURL, err)
       }

       // Verify the URL has required components
       if parsedURL.Scheme == "" {
           return fmt.Errorf("NBU server URL missing scheme: %s", baseURL)
       }
       if parsedURL.Host == "" {
           return fmt.Errorf("NBU server URL missing host: %s", baseURL)
       }

       return nil
   }
   ```

2. Call `validateNBUBaseURL()` in `Validate()` after `validateNBUServerConfig()`:

   ```go
   func (c *Config) Validate() error {
       c.SetDefaults()

       if err := c.validateServerConfig(); err != nil {
           return err
       }

       if err := c.validateNBUServerConfig(); err != nil {
           return err
       }

       // Validate the composed URL is valid
       if err := c.validateNBUBaseURL(); err != nil {
           return err
       }

       if err := c.validateAPIVersion(); err != nil {
           return err
       }

       if err := c.validateOpenTelemetryConfig(); err != nil {
           return err
       }

       return nil
   }
   ```

3. Update `BuildURL()` to return an error instead of silently ignoring parse failures:

   ```go
   // BuildURL constructs a complete URL from the base URL, path, and query parameters.
   // Returns an error if the base URL cannot be parsed.
   //
   // Note: Config.Validate() should be called before using BuildURL to ensure
   // the base URL is valid. This error return is a defensive check.
   func (c *Config) BuildURL(path string, queryParams map[string]string) (string, error) {
       u, err := url.Parse(c.GetNBUBaseURL())
       if err != nil {
           return "", fmt.Errorf("failed to parse base URL: %w", err)
       }

       u.Path = u.Path + path
       q := u.Query()
       for key, value := range queryParams {
           q.Set(key, value)
       }
       u.RawQuery = q.Encode()
       return u.String(), nil
   }
   ```

4. Since changing BuildURL signature is a breaking change, create an alternative:
   - Keep original BuildURL() for backwards compatibility but add a comment noting it assumes validated config
   - Add BuildURLSafe() that returns error
   - Or: Change signature and update all callers (check for callers first with grep)
     </action>
     <verify>
     Run `go build ./...` to ensure compilation succeeds.
     Run `go test ./internal/models/... -v` to verify existing tests pass.
     </verify>
     <done>
     validateNBUBaseURL() function added. Validate() calls validateNBUBaseURL(). URL validation occurs during config validation before any API calls are made.
     </done>
     </task>

<task type="auto">
  <name>Task 2: Update BuildURL callers and add tests</name>
  <files>internal/models/Config.go, internal/models/Config_test.go</files>
  <action>
First, check for BuildURL callers:
```bash
grep -r "BuildURL" --include="*.go" .
```

Then update based on findings:

1. If BuildURL is only called internally or in tests, change the signature to return error.

2. If BuildURL is called from exporter code, either:
   a. Update callers to handle the error
   b. Keep BuildURL unchanged but add internal validation (since Validate() now checks URL)

3. Add comprehensive tests for URL validation in Config_test.go:

```go
func TestConfigValidateInvalidURL(t *testing.T) {
    tests := []struct {
        name        string
        host        string
        port        string
        scheme      string
        expectError bool
        errorContains string
    }{
        {
            name:        "valid URL components",
            host:        "nbu-master.example.com",
            port:        "1556",
            scheme:      "https",
            expectError: false,
        },
        {
            name:        "host with invalid characters",
            host:        "nbu master.example.com", // space in hostname
            port:        "1556",
            scheme:      "https",
            expectError: true,
            errorContains: "invalid",
        },
        {
            name:        "empty host caught by existing validation",
            host:        "",
            port:        "1556",
            scheme:      "https",
            expectError: true,
            errorContains: "host is required",
        },
        {
            name:        "invalid scheme",
            host:        "nbu-master.example.com",
            port:        "1556",
            scheme:      "ftp", // not http/https
            expectError: true,
            errorContains: "scheme",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cfg := createValidTestConfig()
            cfg.NbuServer.Host = tt.host
            cfg.NbuServer.Port = tt.port
            cfg.NbuServer.Scheme = tt.scheme

            err := cfg.Validate()

            if tt.expectError {
                if err == nil {
                    t.Errorf("Validate() expected error, got nil")
                } else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
                    t.Errorf("Validate() error = %v, want error containing %q", err, tt.errorContains)
                }
            } else {
                if err != nil {
                    t.Errorf("Validate() unexpected error = %v", err)
                }
            }
        })
    }
}

func TestConfigBuildURL(t *testing.T) {
    tests := []struct {
        name        string
        path        string
        queryParams map[string]string
        wantContains string
    }{
        {
            name:        "builds URL with path and params",
            path:        "/admin/jobs",
            queryParams: map[string]string{"page[limit]": "100"},
            wantContains: "/admin/jobs",
        },
        {
            name:        "encodes query parameters",
            path:        "/admin/jobs",
            queryParams: map[string]string{"filter": "status eq 0"},
            wantContains: "filter=",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            cfg := createValidTestConfig()
            _ = cfg.Validate() // Ensure defaults are set

            result := cfg.BuildURL(tt.path, tt.queryParams)

            if !strings.Contains(result, tt.wantContains) {
                t.Errorf("BuildURL() = %v, want to contain %q", result, tt.wantContains)
            }
        })
    }
}
```

1. Add helper function `createValidTestConfig()` if it doesn't exist:

```go
func createValidTestConfig() Config {
    return Config{
        Server: struct {
            Port             string `yaml:"port"`
            Host             string `yaml:"host"`
            URI              string `yaml:"uri"`
            ScrapingInterval string `yaml:"scrapingInterval"`
            LogName          string `yaml:"logName"`
        }{
            Port:             "2112",
            Host:             "0.0.0.0",
            URI:              "/metrics",
            ScrapingInterval: "5m",
            LogName:          "test.log",
        },
        NbuServer: struct {
            Port               string `yaml:"port"`
            Scheme             string `yaml:"scheme"`
            URI                string `yaml:"uri"`
            Domain             string `yaml:"domain"`
            DomainType         string `yaml:"domainType"`
            Host               string `yaml:"host"`
            APIKey             string `yaml:"apiKey"`
            APIVersion         string `yaml:"apiVersion"`
            ContentType        string `yaml:"contentType"`
            InsecureSkipVerify bool   `yaml:"insecureSkipVerify"`
        }{
            Port:               "1556",
            Scheme:             "https",
            URI:                "/netbackup",
            Host:               "nbu-master.example.com",
            APIKey:             "test-api-key-12345678",
            APIVersion:         "13.0",
            InsecureSkipVerify: true,
        },
    }
}
```

  </action>
  <verify>
Run `go test ./internal/models/... -v` to verify all tests pass.
Run `go test ./... -v` to verify no regressions in other packages.
  </verify>
  <done>
URL validation tests added. Tests verify: (1) valid URLs pass validation, (2) invalid hostnames are caught, (3) invalid schemes are rejected, (4) BuildURL produces correct output for valid configs.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `go test ./... -v`
2. Verify config validation catches invalid URLs: Check test output for TestConfigValidateInvalidURL
3. Build binary: `make cli`
4. Test with intentionally malformed config to verify error message clarity
</verification>

<success_criteria>

- Config.Validate() now calls validateNBUBaseURL()
- Invalid URL components are caught at startup with clear error messages
- Error messages include the problematic URL and reason for failure
- All existing tests pass
- New tests verify URL validation behavior
- BuildURL behavior is documented (assumes validated config or returns error)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fixes-stability/01-02-SUMMARY.md`
</output>
