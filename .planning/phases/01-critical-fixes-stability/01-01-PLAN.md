---
phase: 01-critical-fixes-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/exporter/version_detector.go
  - internal/exporter/version_detector_test.go
  - internal/exporter/client.go
autonomous: true

must_haves:
  truths:
    - "Version detection returns detected version without mutating input config"
    - "Context cancellation during version detection leaves no inconsistent state"
    - "APIVersionDetector does not hold mutable reference to config"
  artifacts:
    - path: "internal/exporter/version_detector.go"
      provides: "Immutable version detection logic"
      contains: "func (d *APIVersionDetector) DetectVersion"
    - path: "internal/exporter/version_detector_test.go"
      provides: "Tests for config immutability during detection"
      contains: "TestAPIVersionDetector.*ConfigImmutability"
  key_links:
    - from: "internal/exporter/version_detector.go"
      to: "internal/exporter/client.go"
      via: "performVersionDetectionIfNeeded updates config after successful detection"
      pattern: "cfg\\.NbuServer\\.APIVersion = detectedVersion"
---

<objective>
Refactor version detection to be immutable and remove shared config mutation

Purpose: Fix BUG-01 (state restoration on context cancellation) and FRAG-01 (shared config reference) by making version detection pure - it returns the detected version without modifying any input state. This eliminates race conditions and ensures context cancellation cannot leave config in an inconsistent state.

Output: Version detector that returns results without side effects, updated client creation that handles version assignment in a single location
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/exporter/version_detector.go
@internal/exporter/client.go
@internal/exporter/version_detector_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor APIVersionDetector to be immutable</name>
  <files>internal/exporter/version_detector.go</files>
  <action>
Refactor the APIVersionDetector to not mutate config during version detection:

1. Remove the `cfg *models.Config` field from APIVersionDetector struct. Instead, store only immutable values needed for detection:
   - `baseURL string` (computed once from config at creation)
   - `apiKey string` (for authentication header)

2. Change `NewAPIVersionDetector` signature:
   - Accept `client *NbuClient` and `baseURL string` and `apiKey string` instead of `*models.Config`
   - Or create a `VersionDetectorConfig` struct with immutable fields

3. Remove `setTemporaryVersion()` and `restoreOriginalVersion()` methods entirely - they are the source of the mutation bug.

4. Modify `tryVersion()` to:
   - Accept version as parameter (already does)
   - Build the test URL with the version inline instead of modifying config
   - Create headers with the test version directly (don't rely on client.getHeaders())

5. Modify `buildTestURL()` to accept version parameter and build URL directly:

   ```go
   func (d *APIVersionDetector) buildTestURL(version string) string {
       return fmt.Sprintf("%s/admin/jobs?page[limit]=1", d.baseURL)
   }
   ```

6. Modify `makeVersionTestRequest()` to accept version and build headers inline:

   ```go
   func (d *APIVersionDetector) makeVersionTestRequest(ctx context.Context, testURL, version string) (*resty.Response, error) {
       headers := map[string]string{
           "Accept":        fmt.Sprintf("application/vnd.netbackup+json;version=%s", version),
           "Authorization": d.apiKey,
       }
       return d.client.client.R().
           SetContext(ctx).
           SetHeaders(headers).
           Get(testURL)
   }
   ```

7. Update `DetectVersion()` to simply return the first working version without any config mutation.

The key insight: Version detection is a query operation - it should not have side effects on the config. The caller (performVersionDetectionIfNeeded in client.go) is responsible for applying the detected version to the config.
</action>
<verify>
Run `go build ./...` to ensure compilation succeeds.
Run `go test ./internal/exporter/... -run TestAPIVersionDetector -v` to verify existing tests still pass.
</verify>
<done>
APIVersionDetector no longer holds \*models.Config reference. setTemporaryVersion() and restoreOriginalVersion() methods are removed. Version detection returns string without modifying any state.
</done>
</task>

<task type="auto">
  <name>Task 2: Update client.go to handle version assignment centrally</name>
  <files>internal/exporter/client.go</files>
  <action>
Update the client creation and version detection integration:

1. Update `NewAPIVersionDetector` call in `performVersionDetectionIfNeeded()`:

   ```go
   func performVersionDetectionIfNeeded(ctx context.Context, client *NbuClient, cfg *models.Config) error {
       if shouldPerformVersionDetection(cfg) {
           logging.LogInfo("API version not configured, performing automatic detection")

           // Create detector with immutable values
           detector := NewAPIVersionDetector(
               client,
               cfg.GetNBUBaseURL(),
               cfg.NbuServer.APIKey,
           )

           detectedVersion, err := detector.DetectVersion(ctx)
           if err != nil {
               return fmt.Errorf("automatic API version detection failed: %w", err)
           }

           // Single point of config mutation - after successful detection
           cfg.NbuServer.APIVersion = detectedVersion
           client.cfg.NbuServer.APIVersion = detectedVersion
           logging.LogInfo(fmt.Sprintf("Automatically detected API version: %s", detectedVersion))
       }
       // ... rest unchanged
   }
   ```

2. The key change is that config mutation happens ONLY after successful detection, in ONE place. If DetectVersion fails or context is cancelled, config remains unchanged.

3. Ensure the client's internal config copy is also updated (client.cfg.NbuServer.APIVersion = detectedVersion) so subsequent requests use the detected version.
   </action>
   <verify>
   Run `go build ./...` to ensure compilation succeeds.
   Run `go test ./internal/exporter/... -v` to verify all client tests pass.
   </verify>
   <done>
   performVersionDetectionIfNeeded() creates detector with immutable values. Config mutation happens only after successful detection in one location.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Add tests for config immutability during version detection</name>
  <files>internal/exporter/version_detector_test.go</files>
  <action>
Add tests that verify config immutability during version detection:

1. Add `TestAPIVersionDetectorConfigImmutability`:

   ```go
   func TestAPIVersionDetectorConfigImmutability(t *testing.T) {
       tests := []struct {
           name           string
           initialVersion string
           serverResponds bool
           description    string
       }{
           {
               name:           "config unchanged when detection succeeds",
               initialVersion: "original-version",
               serverResponds: true,
               description:    "Original config value preserved during detection",
           },
           {
               name:           "config unchanged when detection fails",
               initialVersion: "original-version",
               serverResponds: false,
               description:    "Original config value preserved on failure",
           },
       }

       for _, tt := range tests {
           t.Run(tt.name, func(t *testing.T) {
               // Create server that may or may not respond successfully
               server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                   if tt.serverResponds {
                       w.WriteHeader(http.StatusOK)
                       json.NewEncoder(w).Encode(mockJobsResponse{})
                   } else {
                       w.WriteHeader(http.StatusNotAcceptable)
                   }
               }))
               defer server.Close()

               // Create config with initial version
               cfg := createTestConfig(server.URL, tt.initialVersion)
               cfg.NbuServer.APIVersion = tt.initialVersion
               originalVersion := cfg.NbuServer.APIVersion

               // Create detector - should not mutate config
               client := NewNbuClient(cfg)
               detector := NewAPIVersionDetector(client, cfg.GetNBUBaseURL(), cfg.NbuServer.APIKey)

               // Run detection
               _, _ = detector.DetectVersion(context.Background())

               // Verify config was NOT mutated by detector
               if cfg.NbuServer.APIVersion != originalVersion {
                   t.Errorf("Config was mutated during detection: got %v, want %v",
                       cfg.NbuServer.APIVersion, originalVersion)
               }
           })
       }
   }
   ```

2. Add `TestAPIVersionDetectorContextCancellationNoConfigMutation`:

   ```go
   func TestAPIVersionDetectorContextCancellationNoConfigMutation(t *testing.T) {
       // Create a slow server
       server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
           time.Sleep(500 * time.Millisecond)
           w.WriteHeader(http.StatusOK)
       }))
       defer server.Close()

       cfg := createTestConfig(server.URL, "13.0")
       originalVersion := "should-not-change"
       cfg.NbuServer.APIVersion = originalVersion

       client := NewNbuClient(cfg)
       detector := NewAPIVersionDetector(client, cfg.GetNBUBaseURL(), cfg.NbuServer.APIKey)

       // Cancel context immediately
       ctx, cancel := context.WithCancel(context.Background())
       cancel()

       // Run detection with cancelled context
       _, _ = detector.DetectVersion(ctx)

       // Verify config was NOT mutated
       if cfg.NbuServer.APIVersion != originalVersion {
           t.Errorf("Config mutated on context cancellation: got %v, want %v",
               cfg.NbuServer.APIVersion, originalVersion)
       }
   }
   ```

3. Update existing tests to use the new detector constructor signature.
   </action>
   <verify>
   Run `go test ./internal/exporter/... -run TestAPIVersionDetector -v` to verify all new and existing tests pass.
   Run `go test ./internal/exporter/... -race` to verify no race conditions.
   </verify>
   <done>
   Tests verify: (1) config unchanged during successful detection, (2) config unchanged on detection failure, (3) config unchanged on context cancellation. All tests pass including race detection.
   </done>
   </task>

</tasks>

<verification>
1. Run full test suite: `go test ./... -v`
2. Run race detector: `go test ./... -race`
3. Verify existing version detection integration tests pass: `go test ./internal/exporter/... -run Version -v`
4. Build binary: `make cli`
</verification>

<success_criteria>

- APIVersionDetector struct no longer contains `*models.Config` field
- setTemporaryVersion() and restoreOriginalVersion() methods are removed
- DetectVersion() returns detected version without any side effects
- Config mutation happens only in performVersionDetectionIfNeeded() after successful detection
- All existing tests pass
- New tests verify config immutability during detection
- Race detector reports no issues
  </success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fixes-stability/01-01-SUMMARY.md`
</output>
