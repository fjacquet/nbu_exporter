---
phase: 01-critical-fixes-stability
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - main.go
autonomous: true

must_haves:
  truths:
    - "HTTP server errors are sent through error channel instead of log.Fatalf"
    - "Exporter continues running even if metric collection errors occur"
    - "Main function handles shutdown gracefully on server errors"
  artifacts:
    - path: "main.go"
      provides: "Error channel pattern for goroutine errors"
      contains: "serverErrChan"
  key_links:
    - from: "main.go goroutine"
      to: "main function select"
      via: "error channel communication"
      pattern: "serverErrChan <- err"
---

<objective>
Replace log.Fatalf in goroutine with error channel pattern

Purpose: Fix TD-06 (fatal log in async goroutine). Currently line 159 in main.go has `log.Fatalf("HTTP server error: %v", err)` inside a goroutine. This exits the process unexpectedly without proper cleanup. The error channel pattern allows the main function to handle errors gracefully.

Output: Main function uses error channel to receive goroutine errors and perform graceful shutdown
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement error channel pattern in Server.Start()</name>
  <files>main.go</files>
  <action>
Refactor the HTTP server startup to use error channels:

1. Add error channel to Server struct:
   ```go
   type Server struct {
       cfg              models.Config
       httpSrv          *http.Server
       registry         *prometheus.Registry
       telemetryManager *telemetry.Manager
       serverErrChan    chan error  // Channel for server errors
   }
   ```

2. Update NewServer() to initialize the error channel:
   ```go
   func NewServer(cfg models.Config) *Server {
       var telemetryMgr *telemetry.Manager
       // ... existing telemetry setup ...

       return &Server{
           cfg:              cfg,
           registry:         prometheus.NewRegistry(),
           telemetryManager: telemetryMgr,
           serverErrChan:    make(chan error, 1), // Buffered to prevent goroutine leak
       }
   }
   ```

3. Modify Server.Start() to send errors through channel instead of calling log.Fatalf:
   ```go
   func (s *Server) Start() error {
       // ... existing setup code (OpenTelemetry, collector, handlers) ...

       // Create HTTP server
       s.httpSrv = &http.Server{
           Addr:              s.cfg.GetServerAddress(),
           Handler:           mux,
           ReadHeaderTimeout: readHeaderTimeout,
       }

       // Start server in goroutine - send errors through channel instead of fatal
       go func() {
           log.Infof("Starting %s on %s%s", programName, s.cfg.GetServerAddress(), s.cfg.Server.URI)
           if err := s.httpSrv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
               // Send error through channel instead of log.Fatalf
               s.serverErrChan <- fmt.Errorf("HTTP server error: %w", err)
           }
       }()

       return nil
   }
   ```

4. Add method to get error channel:
   ```go
   // ErrorChan returns the channel for receiving server errors.
   // The main function should select on this channel to handle errors gracefully.
   func (s *Server) ErrorChan() <-chan error {
       return s.serverErrChan
   }
   ```

5. Update Shutdown() to close the error channel:
   ```go
   func (s *Server) Shutdown() error {
       // ... existing shutdown code ...

       // Close error channel to signal no more errors will be sent
       close(s.serverErrChan)

       log.Info("Server stopped gracefully")
       return nil
   }
   ```
  </action>
  <verify>
Run `go build ./...` to ensure compilation succeeds.
  </verify>
  <done>
Server struct has serverErrChan field. Start() sends errors through channel. ErrorChan() method provides read-only access to channel. Shutdown() closes channel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update main function to handle server errors via select</name>
  <files>main.go</files>
  <action>
Update the main function to use error channel:

1. Replace simple signal wait with select on multiple channels:
   ```go
   func main() {
       rootCmd := &cobra.Command{
           Use:   programName,
           Short: "Prometheus exporter for Veritas NetBackup",
           Long:  "NBU Exporter collects metrics from NetBackup API and exposes them in Prometheus format",
           RunE: func(cmd *cobra.Command, args []string) error {
               // ... existing config and logging setup ...

               // Create and start server
               server := NewServer(*cfg)
               if err := server.Start(); err != nil {
                   return err
               }

               // Setup signal handling
               stop := make(chan os.Signal, 1)
               signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

               // Wait for either shutdown signal or server error
               select {
               case sig := <-stop:
                   log.Infof("Received signal %v, initiating graceful shutdown...", sig)
               case err := <-server.ErrorChan():
                   if err != nil {
                       log.Errorf("Server error: %v", err)
                       // Still perform graceful shutdown on error
                   }
               }

               // Graceful shutdown
               return server.Shutdown()
           },
       }

       // ... rest of CLI setup ...
   }
   ```

2. Remove the waitForShutdownSignal() helper function since logic is now inline:
   ```go
   // DELETE THIS FUNCTION:
   // func waitForShutdownSignal() {
   //     stop := make(chan os.Signal, 1)
   //     signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
   //     <-stop
   // }
   ```

   Or keep it but update the main to use the select pattern.

3. Alternative approach - update waitForShutdownSignal to accept error channel:
   ```go
   // waitForShutdown blocks until either a shutdown signal is received
   // or a server error occurs through the error channel.
   func waitForShutdown(serverErr <-chan error) error {
       stop := make(chan os.Signal, 1)
       signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

       select {
       case sig := <-stop:
           log.Infof("Received signal %v, initiating graceful shutdown...", sig)
           return nil
       case err := <-serverErr:
           if err != nil {
               return err
           }
           return nil
       }
   }
   ```

   Then in RunE:
   ```go
   // Wait for shutdown signal or server error
   if err := waitForShutdown(server.ErrorChan()); err != nil {
       log.Errorf("Server error: %v", err)
       // Continue to graceful shutdown
   }

   // Graceful shutdown
   return server.Shutdown()
   ```
  </action>
  <verify>
Run `go build ./...` to ensure compilation succeeds.
Run `./bin/nbu_exporter --help` to verify binary works.
  </verify>
  <done>
Main function uses select to wait on shutdown signal or error channel. Server errors trigger graceful shutdown instead of abrupt exit. waitForShutdownSignal refactored or removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add documentation and verify behavior</name>
  <files>main.go</files>
  <action>
Add documentation and verify the error handling:

1. Add comprehensive documentation to the error handling pattern:
   ```go
   // Server encapsulates the HTTP server and its dependencies for serving Prometheus metrics.
   // It manages the lifecycle of the HTTP server, Prometheus registry, NetBackup collector,
   // and OpenTelemetry telemetry manager.
   //
   // Error Handling:
   // Server errors (such as port binding failures) are communicated through the ErrorChan()
   // channel rather than calling log.Fatal. This allows the caller to perform graceful
   // shutdown even when the server encounters errors.
   //
   // Usage:
   //
   //     server := NewServer(cfg)
   //     if err := server.Start(); err != nil {
   //         return err
   //     }
   //
   //     select {
   //     case <-shutdownSignal:
   //         // Normal shutdown
   //     case err := <-server.ErrorChan():
   //         log.Errorf("Server error: %v", err)
   //     }
   //
   //     server.Shutdown()
   type Server struct {
       // ... fields ...
   }
   ```

2. Test the error path manually:
   - Start exporter on a port that's already in use
   - Verify it logs the error and exits cleanly (exit code 1, not panic)
   - Verify no goroutine leak warnings

3. Ensure the error channel is buffered (capacity 1) to prevent goroutine leak if no one reads from it immediately:
   ```go
   serverErrChan: make(chan error, 1), // Buffered to prevent goroutine leak
   ```

4. Add comment explaining why the channel is buffered:
   ```go
   // serverErrChan receives HTTP server errors. It is buffered (capacity 1)
   // to ensure the goroutine can send an error even if the main select
   // hasn't started listening yet (race between Start() return and select).
   serverErrChan chan error
   ```
  </action>
  <verify>
Run `make cli` to build binary.
Test error path: Start exporter on port 80 (requires root) or already-used port to verify error handling.
Verify exit is clean with proper error message.
  </verify>
  <done>
Error channel pattern fully documented. Buffer prevents goroutine leaks. Manual testing confirms server errors result in graceful shutdown with proper error logging.
  </done>
</task>

</tasks>

<verification>
1. Build binary: `make cli`
2. Test normal startup and shutdown: `./bin/nbu_exporter -c config.yaml` then Ctrl+C
3. Test error handling: Start exporter on an already-used port, verify clean error and exit
4. Run `go vet ./...` to check for common mistakes
5. Run `go build -race ./...` to verify no race conditions in error channel usage
</verification>

<success_criteria>
- log.Fatalf removed from goroutine in main.go
- Server struct has serverErrChan field with buffered channel (capacity 1)
- Start() sends HTTP server errors through channel
- Main function uses select to handle both signals and server errors
- Server errors trigger graceful shutdown (Shutdown() is called)
- Clean exit code (non-zero) on server errors with informative message
- No goroutine leaks due to unbuffered channel
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fixes-stability/01-04-SUMMARY.md`
</output>
