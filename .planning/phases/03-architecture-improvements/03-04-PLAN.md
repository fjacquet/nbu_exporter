---
phase: 03-architecture-improvements
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/models/immutable.go
  - internal/models/immutable_test.go
autonomous: true

must_haves:
  truths:
    - "Configuration values cannot be modified after ImmutableConfig creation"
    - "Version detection completes before ImmutableConfig is created"
    - "ImmutableConfig type created and available for incremental adoption"
  artifacts:
    - path: "internal/models/immutable.go"
      provides: "ImmutableConfig type with accessor methods"
      exports: ["ImmutableConfig", "NewImmutableConfig"]
    - path: "internal/models/immutable_test.go"
      provides: "Tests verifying immutability guarantees"
      contains: "TestImmutableConfig"
  key_links:
    - from: "internal/models/immutable.go"
      to: "internal/models/Config.go"
      via: "NewImmutableConfig constructor"
      pattern: "NewImmutableConfig"
---

<objective>
Create ImmutableConfig type that extracts runtime configuration values after validation and version detection, ensuring config cannot be modified during execution.

Purpose: Implements TD-01 - configuration objects immutable after initialization, completing the pattern started in Phase 1.

Output: ImmutableConfig type in models package ready for incremental adoption.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-architecture-improvements/03-RESEARCH.md

@internal/models/Config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImmutableConfig type</name>
  <files>internal/models/immutable.go</files>
  <action>
Create new file internal/models/immutable.go with ImmutableConfig type:

```go
// Package models defines the core data structures for the NBU exporter application.
package models

import (
    "time"
)

// ImmutableConfig holds configuration values that are fixed after initialization.
// This type is created after validation and version detection complete, ensuring
// all values are finalized and cannot be modified during execution.
//
// Design rationale:
// - Separates mutable YAML parsing (Config) from immutable runtime use (ImmutableConfig)
// - Guarantees thread-safety: no synchronization needed for reads
// - Makes dependencies explicit: components declare they need finalized config
// - Prevents accidental modification bugs
type ImmutableConfig struct {
    // NBU server connection settings
    baseURL            string
    apiKey             string
    apiVersion         string
    insecureSkipVerify bool

    // Server settings
    serverAddress    string
    metricsURI       string
    scrapingInterval time.Duration
    logName          string

    // OpenTelemetry settings
    otelEnabled      bool
    otelEndpoint     string
    otelInsecure     bool
    otelSamplingRate float64
}

// NewImmutableConfig creates an ImmutableConfig from a validated Config.
// This should be called AFTER:
//   1. Config.Validate() has passed
//   2. Version detection has completed (if needed)
//   3. All config mutations are complete
//
// Returns an error if scraping interval cannot be parsed.
func NewImmutableConfig(cfg *Config) (ImmutableConfig, error) {
    scrapingDuration, err := cfg.GetScrapingDuration()
    if err != nil {
        return ImmutableConfig{}, err
    }

    return ImmutableConfig{
        // NBU server
        baseURL:            cfg.GetNBUBaseURL(),
        apiKey:             cfg.NbuServer.APIKey,
        apiVersion:         cfg.NbuServer.APIVersion,
        insecureSkipVerify: cfg.NbuServer.InsecureSkipVerify,

        // Server
        serverAddress:    cfg.GetServerAddress(),
        metricsURI:       cfg.Server.URI,
        scrapingInterval: scrapingDuration,
        logName:          cfg.Server.LogName,

        // OpenTelemetry
        otelEnabled:      cfg.OpenTelemetry.Enabled,
        otelEndpoint:     cfg.OpenTelemetry.Endpoint,
        otelInsecure:     cfg.OpenTelemetry.Insecure,
        otelSamplingRate: cfg.OpenTelemetry.SamplingRate,
    }, nil
}

// Accessor methods - all return copies/values, not references

// BaseURL returns the complete NBU server base URL.
func (c ImmutableConfig) BaseURL() string {
    return c.baseURL
}

// APIKey returns the NBU API key for authentication.
// SECURITY: Handle with care - do not log this value.
func (c ImmutableConfig) APIKey() string {
    return c.apiKey
}

// APIVersion returns the NBU API version string.
func (c ImmutableConfig) APIVersion() string {
    return c.apiVersion
}

// InsecureSkipVerify returns whether TLS verification is disabled.
func (c ImmutableConfig) InsecureSkipVerify() bool {
    return c.insecureSkipVerify
}

// ServerAddress returns the HTTP server bind address (host:port).
func (c ImmutableConfig) ServerAddress() string {
    return c.serverAddress
}

// MetricsURI returns the metrics endpoint URI path.
func (c ImmutableConfig) MetricsURI() string {
    return c.metricsURI
}

// ScrapingInterval returns the job data time window.
func (c ImmutableConfig) ScrapingInterval() time.Duration {
    return c.scrapingInterval
}

// ScrapingIntervalString returns the scraping interval as a duration string.
func (c ImmutableConfig) ScrapingIntervalString() string {
    return c.scrapingInterval.String()
}

// LogName returns the log file name.
func (c ImmutableConfig) LogName() string {
    return c.logName
}

// OTelEnabled returns whether OpenTelemetry is enabled.
func (c ImmutableConfig) OTelEnabled() bool {
    return c.otelEnabled
}

// OTelEndpoint returns the OTLP endpoint address.
func (c ImmutableConfig) OTelEndpoint() string {
    return c.otelEndpoint
}

// OTelInsecure returns whether OTLP uses insecure connection.
func (c ImmutableConfig) OTelInsecure() bool {
    return c.otelInsecure
}

// OTelSamplingRate returns the trace sampling rate.
func (c ImmutableConfig) OTelSamplingRate() float64 {
    return c.otelSamplingRate
}

// MaskedAPIKey returns a masked version of the API key for safe logging.
func (c ImmutableConfig) MaskedAPIKey() string {
    if len(c.apiKey) <= 8 {
        return "****"
    }
    return c.apiKey[:4] + "****" + c.apiKey[len(c.apiKey)-4:]
}
```
  </action>
  <verify>
- `go build ./internal/models/...` compiles
- `grep -n "type ImmutableConfig struct" internal/models/immutable.go` shows the type
  </verify>
  <done>
ImmutableConfig type created with all accessor methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for ImmutableConfig</name>
  <files>internal/models/immutable_test.go</files>
  <action>
Create comprehensive tests for ImmutableConfig:

```go
package models

import (
    "testing"
    "time"
)

func createValidConfig() *Config {
    cfg := &Config{}
    cfg.Server.Host = "0.0.0.0"
    cfg.Server.Port = "2112"
    cfg.Server.URI = "/metrics"
    cfg.Server.ScrapingInterval = "5m"
    cfg.Server.LogName = "test.log"

    cfg.NbuServer.Scheme = "https"
    cfg.NbuServer.Host = "nbu.example.com"
    cfg.NbuServer.Port = "1556"
    cfg.NbuServer.URI = "/netbackup"
    cfg.NbuServer.APIKey = "test-api-key-12345678"
    cfg.NbuServer.APIVersion = "13.0"
    cfg.NbuServer.InsecureSkipVerify = false

    cfg.OpenTelemetry.Enabled = true
    cfg.OpenTelemetry.Endpoint = "localhost:4317"
    cfg.OpenTelemetry.Insecure = true
    cfg.OpenTelemetry.SamplingRate = 0.5

    return cfg
}

func TestNewImmutableConfig_Success(t *testing.T) {
    cfg := createValidConfig()

    immutable, err := NewImmutableConfig(cfg)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify NBU settings
    expectedURL := "https://nbu.example.com:1556/netbackup"
    if immutable.BaseURL() != expectedURL {
        t.Errorf("expected baseURL %s, got %s", expectedURL, immutable.BaseURL())
    }
    if immutable.APIKey() != "test-api-key-12345678" {
        t.Error("API key mismatch")
    }
    if immutable.APIVersion() != "13.0" {
        t.Errorf("expected API version 13.0, got %s", immutable.APIVersion())
    }
    if immutable.InsecureSkipVerify() != false {
        t.Error("expected InsecureSkipVerify false")
    }

    // Verify server settings
    if immutable.ServerAddress() != "0.0.0.0:2112" {
        t.Errorf("expected server address 0.0.0.0:2112, got %s", immutable.ServerAddress())
    }
    if immutable.MetricsURI() != "/metrics" {
        t.Errorf("expected metrics URI /metrics, got %s", immutable.MetricsURI())
    }
    if immutable.ScrapingInterval() != 5*time.Minute {
        t.Errorf("expected 5m, got %v", immutable.ScrapingInterval())
    }

    // Verify OTel settings
    if !immutable.OTelEnabled() {
        t.Error("expected OTel enabled")
    }
    if immutable.OTelSamplingRate() != 0.5 {
        t.Errorf("expected sampling rate 0.5, got %f", immutable.OTelSamplingRate())
    }
}

func TestNewImmutableConfig_InvalidScrapingInterval(t *testing.T) {
    cfg := createValidConfig()
    cfg.Server.ScrapingInterval = "invalid"

    _, err := NewImmutableConfig(cfg)
    if err == nil {
        t.Error("expected error for invalid scraping interval")
    }
}

func TestImmutableConfig_MaskedAPIKey(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    masked := immutable.MaskedAPIKey()
    if masked != "test****5678" {
        t.Errorf("expected test****5678, got %s", masked)
    }
}

func TestImmutableConfig_MaskedAPIKey_Short(t *testing.T) {
    cfg := createValidConfig()
    cfg.NbuServer.APIKey = "short"
    immutable, _ := NewImmutableConfig(cfg)

    masked := immutable.MaskedAPIKey()
    if masked != "****" {
        t.Errorf("expected ****, got %s", masked)
    }
}

func TestImmutableConfig_ScrapingIntervalString(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    intervalStr := immutable.ScrapingIntervalString()
    if intervalStr != "5m0s" {
        t.Errorf("expected 5m0s, got %s", intervalStr)
    }
}

func TestImmutableConfig_ValuesAreSnapshots(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    // Modify original config
    cfg.NbuServer.APIVersion = "99.0"
    cfg.NbuServer.Host = "modified.example.com"

    // ImmutableConfig should retain original values
    if immutable.APIVersion() != "13.0" {
        t.Error("ImmutableConfig should not be affected by Config changes")
    }
    if immutable.BaseURL() != "https://nbu.example.com:1556/netbackup" {
        t.Error("ImmutableConfig baseURL should not be affected by Config changes")
    }
}
```
  </action>
  <verify>
- `go test ./internal/models/... -run TestImmutableConfig -v` all tests pass
  </verify>
  <done>
ImmutableConfig tests verify correct value extraction and snapshot behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document incremental adoption path</name>
  <files>internal/models/immutable.go</files>
  <action>
Add package-level documentation explaining the adoption path for ImmutableConfig:

At the top of immutable.go, after the package declaration but before the type definition, add:

```go
// ImmutableConfig Usage Pattern
//
// ImmutableConfig is designed for incremental adoption. The recommended pattern is:
//
//   1. Parse and validate Config from YAML (existing code)
//   2. Run version detection if needed (existing code)
//   3. Create ImmutableConfig: immCfg, err := NewImmutableConfig(cfg)
//   4. Pass ImmutableConfig to new components
//
// For existing components (NbuClient, NbuCollector), migration can be done incrementally
// in future phases. The ImmutableConfig type is available now for:
//   - New code paths that need thread-safe config access
//   - Gradual migration of existing components
//   - Clear separation between setup-time and runtime configuration
//
// Full migration of NbuClient and NbuCollector to use only ImmutableConfig internally
// is planned for a future phase. This provides the type and pattern; incremental
// adoption can follow without breaking changes.
```

Note: This task adds documentation only. No code changes to client.go or prometheus.go are made in this plan. Component migration is deferred to a future phase.
  </action>
  <verify>
- `go build ./internal/models/...` compiles
- Documentation visible: `grep -n "ImmutableConfig Usage Pattern" internal/models/immutable.go`
  </verify>
  <done>
ImmutableConfig documented with incremental adoption guidance.
  </done>
</task>

<task type="auto">
  <name>Task 4: Test and commit</name>
  <files>internal/models/immutable.go, internal/models/immutable_test.go</files>
  <action>
1. Run full test suite:
```bash
go test ./... -race
```

2. Verify build:
```bash
go build ./...
```

3. Commit:
```bash
git add internal/models/immutable.go internal/models/immutable_test.go
git commit -m "feat(03-04): add ImmutableConfig type for runtime configuration

Implements TD-01: configuration objects immutable after initialization.

- Create ImmutableConfig type with private fields and accessor methods
- NewImmutableConfig extracts values from validated Config
- Values are snapshots: changes to original Config don't affect ImmutableConfig
- Add MaskedAPIKey() for safe logging
- Document incremental adoption path for existing components
- Full component migration deferred for future phase

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```
  </action>
  <verify>
- `go test ./... -race` passes
- `git log -1 --oneline` shows commit
  </verify>
  <done>
ImmutableConfig type created and tested, ready for incremental adoption.
  </done>
</task>

</tasks>

<verification>
1. ImmutableConfig type exists in internal/models/immutable.go
2. NewImmutableConfig creates config from validated Config
3. All accessor methods return correct values
4. Modifying original Config doesn't affect ImmutableConfig
5. Tests verify immutability guarantees
6. All tests pass
</verification>

<success_criteria>
- ImmutableConfig type with private fields exists
- Accessor methods provide read-only access to all configuration values
- NewImmutableConfig extracts values after validation complete
- Original Config modifications don't affect ImmutableConfig
- Tests verify snapshot behavior
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-improvements/03-04-SUMMARY.md`
</output>
