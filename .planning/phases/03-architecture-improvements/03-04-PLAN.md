---
phase: 03-architecture-improvements
plan: 04
type: execute
wave: 3
depends_on: []
files_modified:
  - internal/models/immutable.go
  - internal/models/immutable_test.go
  - internal/exporter/client.go
  - internal/exporter/prometheus.go
autonomous: true

must_haves:
  truths:
    - "Configuration values cannot be modified after ImmutableConfig creation"
    - "Version detection completes before ImmutableConfig is created"
    - "Components use ImmutableConfig instead of mutable models.Config"
  artifacts:
    - path: "internal/models/immutable.go"
      provides: "ImmutableConfig type with accessor methods"
      exports: ["ImmutableConfig", "NewImmutableConfig"]
    - path: "internal/models/immutable_test.go"
      provides: "Tests verifying immutability guarantees"
      contains: "TestImmutableConfig"
  key_links:
    - from: "internal/exporter/client.go"
      to: "internal/models/immutable.go"
      via: "ImmutableConfig usage"
      pattern: "ImmutableConfig"
---

<objective>
Create ImmutableConfig type that extracts runtime configuration values after validation and version detection, ensuring config cannot be modified during execution.

Purpose: Implements TD-01 - configuration objects immutable after initialization, completing the pattern started in Phase 1.

Output: ImmutableConfig type in models package, components updated to use it.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-architecture-improvements/03-RESEARCH.md

@internal/models/Config.go
@internal/exporter/client.go
@internal/exporter/prometheus.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImmutableConfig type</name>
  <files>internal/models/immutable.go</files>
  <action>
Create new file internal/models/immutable.go with ImmutableConfig type:

```go
// Package models defines the core data structures for the NBU exporter application.
package models

import (
    "time"
)

// ImmutableConfig holds configuration values that are fixed after initialization.
// This type is created after validation and version detection complete, ensuring
// all values are finalized and cannot be modified during execution.
//
// Design rationale:
// - Separates mutable YAML parsing (Config) from immutable runtime use (ImmutableConfig)
// - Guarantees thread-safety: no synchronization needed for reads
// - Makes dependencies explicit: components declare they need finalized config
// - Prevents accidental modification bugs
type ImmutableConfig struct {
    // NBU server connection settings
    baseURL            string
    apiKey             string
    apiVersion         string
    insecureSkipVerify bool

    // Server settings
    serverAddress    string
    metricsURI       string
    scrapingInterval time.Duration
    logName          string

    // OpenTelemetry settings
    otelEnabled      bool
    otelEndpoint     string
    otelInsecure     bool
    otelSamplingRate float64
}

// NewImmutableConfig creates an ImmutableConfig from a validated Config.
// This should be called AFTER:
//   1. Config.Validate() has passed
//   2. Version detection has completed (if needed)
//   3. All config mutations are complete
//
// Returns an error if scraping interval cannot be parsed.
func NewImmutableConfig(cfg *Config) (ImmutableConfig, error) {
    scrapingDuration, err := cfg.GetScrapingDuration()
    if err != nil {
        return ImmutableConfig{}, err
    }

    return ImmutableConfig{
        // NBU server
        baseURL:            cfg.GetNBUBaseURL(),
        apiKey:             cfg.NbuServer.APIKey,
        apiVersion:         cfg.NbuServer.APIVersion,
        insecureSkipVerify: cfg.NbuServer.InsecureSkipVerify,

        // Server
        serverAddress:    cfg.GetServerAddress(),
        metricsURI:       cfg.Server.URI,
        scrapingInterval: scrapingDuration,
        logName:          cfg.Server.LogName,

        // OpenTelemetry
        otelEnabled:      cfg.OpenTelemetry.Enabled,
        otelEndpoint:     cfg.OpenTelemetry.Endpoint,
        otelInsecure:     cfg.OpenTelemetry.Insecure,
        otelSamplingRate: cfg.OpenTelemetry.SamplingRate,
    }, nil
}

// Accessor methods - all return copies/values, not references

// BaseURL returns the complete NBU server base URL.
func (c ImmutableConfig) BaseURL() string {
    return c.baseURL
}

// APIKey returns the NBU API key for authentication.
// SECURITY: Handle with care - do not log this value.
func (c ImmutableConfig) APIKey() string {
    return c.apiKey
}

// APIVersion returns the NBU API version string.
func (c ImmutableConfig) APIVersion() string {
    return c.apiVersion
}

// InsecureSkipVerify returns whether TLS verification is disabled.
func (c ImmutableConfig) InsecureSkipVerify() bool {
    return c.insecureSkipVerify
}

// ServerAddress returns the HTTP server bind address (host:port).
func (c ImmutableConfig) ServerAddress() string {
    return c.serverAddress
}

// MetricsURI returns the metrics endpoint URI path.
func (c ImmutableConfig) MetricsURI() string {
    return c.metricsURI
}

// ScrapingInterval returns the job data time window.
func (c ImmutableConfig) ScrapingInterval() time.Duration {
    return c.scrapingInterval
}

// ScrapingIntervalString returns the scraping interval as a duration string.
func (c ImmutableConfig) ScrapingIntervalString() string {
    return c.scrapingInterval.String()
}

// LogName returns the log file name.
func (c ImmutableConfig) LogName() string {
    return c.logName
}

// OTelEnabled returns whether OpenTelemetry is enabled.
func (c ImmutableConfig) OTelEnabled() bool {
    return c.otelEnabled
}

// OTelEndpoint returns the OTLP endpoint address.
func (c ImmutableConfig) OTelEndpoint() string {
    return c.otelEndpoint
}

// OTelInsecure returns whether OTLP uses insecure connection.
func (c ImmutableConfig) OTelInsecure() bool {
    return c.otelInsecure
}

// OTelSamplingRate returns the trace sampling rate.
func (c ImmutableConfig) OTelSamplingRate() float64 {
    return c.otelSamplingRate
}

// MaskedAPIKey returns a masked version of the API key for safe logging.
func (c ImmutableConfig) MaskedAPIKey() string {
    if len(c.apiKey) <= 8 {
        return "****"
    }
    return c.apiKey[:4] + "****" + c.apiKey[len(c.apiKey)-4:]
}
```
  </action>
  <verify>
- `go build ./internal/models/...` compiles
- `grep -n "type ImmutableConfig struct" internal/models/immutable.go` shows the type
  </verify>
  <done>
ImmutableConfig type created with all accessor methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for ImmutableConfig</name>
  <files>internal/models/immutable_test.go</files>
  <action>
Create comprehensive tests for ImmutableConfig:

```go
package models

import (
    "testing"
    "time"
)

func createValidConfig() *Config {
    cfg := &Config{}
    cfg.Server.Host = "0.0.0.0"
    cfg.Server.Port = "2112"
    cfg.Server.URI = "/metrics"
    cfg.Server.ScrapingInterval = "5m"
    cfg.Server.LogName = "test.log"

    cfg.NbuServer.Scheme = "https"
    cfg.NbuServer.Host = "nbu.example.com"
    cfg.NbuServer.Port = "1556"
    cfg.NbuServer.URI = "/netbackup"
    cfg.NbuServer.APIKey = "test-api-key-12345678"
    cfg.NbuServer.APIVersion = "13.0"
    cfg.NbuServer.InsecureSkipVerify = false

    cfg.OpenTelemetry.Enabled = true
    cfg.OpenTelemetry.Endpoint = "localhost:4317"
    cfg.OpenTelemetry.Insecure = true
    cfg.OpenTelemetry.SamplingRate = 0.5

    return cfg
}

func TestNewImmutableConfig_Success(t *testing.T) {
    cfg := createValidConfig()

    immutable, err := NewImmutableConfig(cfg)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify NBU settings
    expectedURL := "https://nbu.example.com:1556/netbackup"
    if immutable.BaseURL() != expectedURL {
        t.Errorf("expected baseURL %s, got %s", expectedURL, immutable.BaseURL())
    }
    if immutable.APIKey() != "test-api-key-12345678" {
        t.Error("API key mismatch")
    }
    if immutable.APIVersion() != "13.0" {
        t.Errorf("expected API version 13.0, got %s", immutable.APIVersion())
    }
    if immutable.InsecureSkipVerify() != false {
        t.Error("expected InsecureSkipVerify false")
    }

    // Verify server settings
    if immutable.ServerAddress() != "0.0.0.0:2112" {
        t.Errorf("expected server address 0.0.0.0:2112, got %s", immutable.ServerAddress())
    }
    if immutable.MetricsURI() != "/metrics" {
        t.Errorf("expected metrics URI /metrics, got %s", immutable.MetricsURI())
    }
    if immutable.ScrapingInterval() != 5*time.Minute {
        t.Errorf("expected 5m, got %v", immutable.ScrapingInterval())
    }

    // Verify OTel settings
    if !immutable.OTelEnabled() {
        t.Error("expected OTel enabled")
    }
    if immutable.OTelSamplingRate() != 0.5 {
        t.Errorf("expected sampling rate 0.5, got %f", immutable.OTelSamplingRate())
    }
}

func TestNewImmutableConfig_InvalidScrapingInterval(t *testing.T) {
    cfg := createValidConfig()
    cfg.Server.ScrapingInterval = "invalid"

    _, err := NewImmutableConfig(cfg)
    if err == nil {
        t.Error("expected error for invalid scraping interval")
    }
}

func TestImmutableConfig_MaskedAPIKey(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    masked := immutable.MaskedAPIKey()
    if masked != "test****5678" {
        t.Errorf("expected test****5678, got %s", masked)
    }
}

func TestImmutableConfig_MaskedAPIKey_Short(t *testing.T) {
    cfg := createValidConfig()
    cfg.NbuServer.APIKey = "short"
    immutable, _ := NewImmutableConfig(cfg)

    masked := immutable.MaskedAPIKey()
    if masked != "****" {
        t.Errorf("expected ****, got %s", masked)
    }
}

func TestImmutableConfig_ScrapingIntervalString(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    intervalStr := immutable.ScrapingIntervalString()
    if intervalStr != "5m0s" {
        t.Errorf("expected 5m0s, got %s", intervalStr)
    }
}

func TestImmutableConfig_ValuesAreSnapshots(t *testing.T) {
    cfg := createValidConfig()
    immutable, _ := NewImmutableConfig(cfg)

    // Modify original config
    cfg.NbuServer.APIVersion = "99.0"
    cfg.NbuServer.Host = "modified.example.com"

    // ImmutableConfig should retain original values
    if immutable.APIVersion() != "13.0" {
        t.Error("ImmutableConfig should not be affected by Config changes")
    }
    if immutable.BaseURL() != "https://nbu.example.com:1556/netbackup" {
        t.Error("ImmutableConfig baseURL should not be affected by Config changes")
    }
}
```
  </action>
  <verify>
- `go test ./internal/models/... -run TestImmutableConfig -v` all tests pass
  </verify>
  <done>
ImmutableConfig tests verify correct value extraction and snapshot behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update NbuClient to use ImmutableConfig (optional)</name>
  <files>internal/exporter/client.go</files>
  <action>
This task provides an OPTIONAL improvement path. The current implementation already stores immutable values in NbuClient struct. The full migration to ImmutableConfig can be done incrementally.

For now, document the pattern and add a constructor option:

1. Add option for ImmutableConfig in client.go:
```go
// WithImmutableConfig sets the configuration from an ImmutableConfig.
// This is the preferred way to configure the client for production use.
func WithImmutableConfig(cfg models.ImmutableConfig) ClientOption {
    return func(o *clientOptions) {
        o.immutableConfig = &cfg
    }
}

// Add to clientOptions struct:
type clientOptions struct {
    tracerProvider  trace.TracerProvider
    immutableConfig *models.ImmutableConfig  // Optional, overrides cfg if set
}
```

2. The full migration (changing NbuClient.cfg from models.Config to models.ImmutableConfig) is a larger refactor that can be done in a future phase. For now, the ImmutableConfig type exists and can be used by new code paths.

3. Document in client.go that ImmutableConfig is the recommended pattern:
```go
// NewNbuClient creates a new NetBackup API client.
//
// For production use, prefer using WithImmutableConfig option after
// version detection is complete:
//
//     immCfg, _ := models.NewImmutableConfig(cfg)
//     client := NewNbuClient(cfg, WithImmutableConfig(immCfg))
//
// The immutable config ensures thread-safety and prevents accidental modifications.
```

Note: Full migration of NbuClient and NbuCollector to use only ImmutableConfig internally is deferred. The current approach provides the type and pattern; incremental adoption can follow.
  </action>
  <verify>
- `go build ./internal/exporter/...` compiles
- ImmutableConfig type is available for use
  </verify>
  <done>
ImmutableConfig type created and ready for incremental adoption.
  </done>
</task>

<task type="auto">
  <name>Task 4: Test and commit</name>
  <files>internal/models/immutable.go, internal/models/immutable_test.go</files>
  <action>
1. Run full test suite:
```bash
go test ./... -race
```

2. Verify build:
```bash
go build ./...
```

3. Commit:
```bash
git add internal/models/immutable.go internal/models/immutable_test.go
git commit -m "feat(03-04): add ImmutableConfig type for runtime configuration

Implements TD-01: configuration objects immutable after initialization.

- Create ImmutableConfig type with private fields and accessor methods
- NewImmutableConfig extracts values from validated Config
- Values are snapshots: changes to original Config don't affect ImmutableConfig
- Add MaskedAPIKey() for safe logging
- Full component migration deferred for incremental adoption

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```
  </action>
  <verify>
- `go test ./... -race` passes
- `git log -1 --oneline` shows commit
  </verify>
  <done>
ImmutableConfig type created and tested, ready for incremental adoption.
  </done>
</task>

</tasks>

<verification>
1. ImmutableConfig type exists in internal/models/immutable.go
2. NewImmutableConfig creates config from validated Config
3. All accessor methods return correct values
4. Modifying original Config doesn't affect ImmutableConfig
5. Tests verify immutability guarantees
6. All tests pass
</verification>

<success_criteria>
- ImmutableConfig type with private fields exists
- Accessor methods provide read-only access to all configuration values
- NewImmutableConfig extracts values after validation complete
- Original Config modifications don't affect ImmutableConfig
- Tests verify snapshot behavior
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-improvements/03-04-SUMMARY.md`
</output>
