---
phase: 03-architecture-improvements
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/exporter/client.go
  - internal/exporter/client_test.go
  - internal/exporter/prometheus.go
  - internal/exporter/prometheus_test.go
  - internal/telemetry/manager.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "TracerProvider is injected via options pattern, not accessed from global state"
    - "Components work correctly without TracerProvider (uses noop default)"
    - "Existing tests pass without modification to tracing setup"
  artifacts:
    - path: "internal/exporter/client.go"
      provides: "NbuClient with TracerProvider injection"
      exports: ["NewNbuClient", "WithTracerProvider", "ClientOption"]
    - path: "internal/exporter/prometheus.go"
      provides: "NbuCollector with TracerProvider injection"
      exports: ["NewNbuCollector", "WithCollectorTracerProvider", "CollectorOption"]
  key_links:
    - from: "internal/exporter/client.go"
      to: "internal/exporter/tracing.go"
      via: "NewTracerWrapper"
      pattern: "NewTracerWrapper"
    - from: "main.go"
      to: "internal/exporter/prometheus.go"
      via: "WithCollectorTracerProvider"
      pattern: "WithCollectorTracerProvider"
---

<objective>
Inject TracerProvider into NbuClient and NbuCollector using the options pattern instead of accessing global otel.GetTracerProvider().

Purpose: Eliminates global OpenTelemetry state access (TD-02), making dependencies explicit and components more testable.

Output: Options pattern for TracerProvider injection in both NbuClient and NbuCollector.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-architecture-improvements/03-RESEARCH.md
@.planning/phases/03-architecture-improvements/03-01-SUMMARY.md

@internal/exporter/client.go
@internal/exporter/prometheus.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add options pattern to NbuClient</name>
  <files>internal/exporter/client.go</files>
  <action>
Add options pattern for TracerProvider injection to NbuClient:

1. Add import for TracerWrapper's noop package if not present

2. Add options types near the top of the file (after constants):

```go
// ClientOption configures optional NbuClient settings.
type ClientOption func(*clientOptions)

type clientOptions struct {
    tracerProvider trace.TracerProvider
}

func defaultClientOptions() clientOptions {
    return clientOptions{
        tracerProvider: nil, // Will use noop via TracerWrapper
    }
}

// WithTracerProvider sets the TracerProvider for distributed tracing.
// If not provided, tracing operations use a noop provider (no overhead).
func WithTracerProvider(tp trace.TracerProvider) ClientOption {
    return func(o *clientOptions) {
        o.tracerProvider = tp
    }
}
```

1. Update NbuClient struct to use TracerWrapper instead of trace.Tracer:

```go
type NbuClient struct {
    client     *resty.Client
    cfg        models.Config
    tracing    *TracerWrapper  // Changed from tracer trace.Tracer
    // ... rest of fields unchanged
}
```

1. Update NewNbuClient signature to accept options:

```go
func NewNbuClient(cfg models.Config, opts ...ClientOption) *NbuClient {
    options := defaultClientOptions()
    for _, opt := range opts {
        opt(&options)
    }
    // ... existing TLS and client setup code ...

    // Replace global tracer access with TracerWrapper
    tracing := NewTracerWrapper(options.tracerProvider, "nbu-exporter/http-client")

    return &NbuClient{
        client:     client,
        cfg:        cfg,
        tracing:    tracing,  // Use TracerWrapper
        activeReqs: 0,
        closed:     false,
    }
}
```

1. Remove the global tracer provider access block:

```go
// REMOVE this block:
// var tracer trace.Tracer
// tracerProvider := otel.GetTracerProvider()
// if tracerProvider != nil {
//     tracer = tracerProvider.Tracer("nbu-exporter/http-client")
// }
```

1. Update all uses of `c.tracer` to use `c.tracing.StartSpan()` or `c.tracing.Tracer()`:
   - In FetchData: `ctx, span := c.tracing.StartSpan(ctx, "http.request", trace.SpanKindClient)`
   - Remove nil-checks on span since TracerWrapper guarantees non-nil spans

2. Update methods that check tracer for nil (recordHTTPAttributes, recordError, injectTraceContext):
   - Remove nil checks - TracerWrapper guarantees non-nil spans
   - Keep span parameter checks for methods that receive span as parameter

3. Update NewNbuClientWithVersionDetection to pass options through:

```go
func NewNbuClientWithVersionDetection(ctx context.Context, cfg *models.Config, opts ...ClientOption) (*NbuClient, error) {
    client := NewNbuClient(*cfg, opts...)
    // ... rest unchanged
}
```

  </action>
  <verify>
- `go build ./internal/exporter/...` compiles without errors
- `grep -n "otel.GetTracerProvider" internal/exporter/client.go` returns empty (no global access)
- `grep -n "TracerWrapper" internal/exporter/client.go` shows TracerWrapper usage
  </verify>
  <done>
NbuClient accepts TracerProvider via options pattern, uses TracerWrapper internally.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add options pattern to NbuCollector</name>
  <files>internal/exporter/prometheus.go</files>
  <action>
Add options pattern for TracerProvider injection to NbuCollector:

1. Add options types after imports:

```go
// CollectorOption configures optional NbuCollector settings.
type CollectorOption func(*collectorOptions)

type collectorOptions struct {
    tracerProvider trace.TracerProvider
}

func defaultCollectorOptions() collectorOptions {
    return collectorOptions{
        tracerProvider: nil, // Will use noop via TracerWrapper
    }
}

// WithCollectorTracerProvider sets the TracerProvider for the collector.
// If not provided, tracing operations use a noop provider (no overhead).
func WithCollectorTracerProvider(tp trace.TracerProvider) CollectorOption {
    return func(o *collectorOptions) {
        o.tracerProvider = tp
    }
}
```

1. Update NbuCollector struct:

```go
type NbuCollector struct {
    cfg     models.Config
    client  *NbuClient
    tracing *TracerWrapper  // Changed from tracer trace.Tracer
    // ... metric descriptors unchanged
}
```

1. Update NewNbuCollector signature:

```go
func NewNbuCollector(cfg models.Config, opts ...CollectorOption) (*NbuCollector, error) {
    options := defaultCollectorOptions()
    for _, opt := range opts {
        opt(&options)
    }

    // Create base client with same TracerProvider
    client := NewNbuClient(cfg, WithTracerProvider(options.tracerProvider))

    // ... version detection unchanged ...

    // Create TracerWrapper for collector
    tracing := NewTracerWrapper(options.tracerProvider, "nbu-exporter/collector")

    return &NbuCollector{
        cfg:     cfg,
        client:  client,
        tracing: tracing,
        // ... metric descriptors unchanged
    }, nil
}
```

1. Remove global tracer access:

```go
// REMOVE: tracer := otel.Tracer("nbu-exporter")
```

1. Update createScrapeSpan to use TracerWrapper:

```go
func (c *NbuCollector) createScrapeSpan(ctx context.Context) (context.Context, trace.Span) {
    return c.tracing.StartSpan(ctx, "prometheus.scrape", trace.SpanKindServer)
}
```

1. Remove nil-check in createScrapeSpan - TracerWrapper guarantees valid span

2. Update Collect method to remove span nil-checks:

```go
func (c *NbuCollector) Collect(ch chan<- prometheus.Metric) {
    ctx, cancel := context.WithTimeout(context.Background(), collectionTimeout)
    defer cancel()

    scrapeStart := time.Now()
    ctx, span := c.createScrapeSpan(ctx)
    defer span.End()  // Always safe now

    // ... rest unchanged but remove if span != nil checks
}
```

1. Update other methods (recordFetchError, updateScrapeSpan, etc.) to remove nil-checks
  </action>

  <verify>
- `go build ./internal/exporter/...` compiles
- `grep -n "otel.Tracer\|otel.GetTracerProvider" internal/exporter/prometheus.go` returns empty
- `grep -n "if span != nil" internal/exporter/prometheus.go` shows reduced nil-checks (ideally zero for TracerWrapper spans)
  </verify>
  <done>
NbuCollector accepts TracerProvider via options, passes to NbuClient, uses TracerWrapper.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update main.go to inject TracerProvider</name>
  <files>main.go</files>
  <action>
Update main.go to inject TracerProvider when creating the collector:

1. In Server.Start(), after telemetry initialization, get the TracerProvider:

```go
func (s *Server) Start() error {
    // Initialize OpenTelemetry if enabled
    var tracerProvider trace.TracerProvider
    if s.telemetryManager != nil {
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := s.telemetryManager.Initialize(ctx); err != nil {
            log.Warnf("Failed to initialize OpenTelemetry: %v. Continuing without tracing.", err)
        }

        if s.telemetryManager.IsEnabled() {
            // Get TracerProvider from telemetry manager
            tracerProvider = s.telemetryManager.TracerProvider()

            // Configure W3C propagation...
        }
    }

    // Create NetBackup collector with injected TracerProvider
    var collectorOpts []exporter.CollectorOption
    if tracerProvider != nil {
        collectorOpts = append(collectorOpts, exporter.WithCollectorTracerProvider(tracerProvider))
    }

    collector, err := exporter.NewNbuCollector(s.cfg, collectorOpts...)
    if err != nil {
        return fmt.Errorf("failed to create collector: %w", err)
    }
    // ... rest unchanged
}
```

1. Add import for trace package if needed:

```go
import "go.opentelemetry.io/otel/trace"
```

1. If telemetry.Manager doesn't expose TracerProvider(), this will need to be added to telemetry/manager.go:

```go
// TracerProvider returns the configured TracerProvider.
// Returns nil if telemetry is not initialized.
func (m *Manager) TracerProvider() trace.TracerProvider {
    return m.provider
}
```

1. Remove the otel.GetTracerProvider() call from main.go if present
  </action>

  <verify>
- `go build ./...` compiles
- `grep -n "otel.GetTracerProvider" main.go` returns empty (or only in propagator setup)
- Server starts correctly with `./bin/nbu_exporter --config config.yaml` (manual test)
  </verify>
  <done>
TracerProvider explicitly injected from telemetry manager into collector.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update tests and verify full suite</name>
  <files>internal/exporter/client_test.go, internal/exporter/prometheus_test.go</files>
  <action>
1. Update existing tests to use new constructor signatures:
   - Tests that call NewNbuClient(cfg) should still work (no options = noop tracing)
   - Tests that call NewNbuCollector(cfg) should still work

1. Add tests for options pattern:

In client_test.go:

```go
func TestNewNbuClient_WithTracerProvider(t *testing.T) {
    cfg := createTestConfig()
    tp := noop.NewTracerProvider()

    client := NewNbuClient(cfg, WithTracerProvider(tp))

    if client == nil {
        t.Fatal("expected non-nil client")
    }
    if client.tracing == nil {
        t.Fatal("expected non-nil tracing wrapper")
    }
}

func TestNewNbuClient_WithoutTracerProvider(t *testing.T) {
    cfg := createTestConfig()

    client := NewNbuClient(cfg) // No options

    if client == nil {
        t.Fatal("expected non-nil client")
    }
    if client.tracing == nil {
        t.Fatal("expected non-nil tracing wrapper even without provider")
    }
}
```

In prometheus_test.go (if exists, or create minimal test):

```go
func TestNewNbuCollector_WithTracerProvider(t *testing.T) {
    // This is an integration test that may need mocking
    // Skip if external dependencies are required
    t.Skip("requires mock server for full test")
}
```

1. Run full test suite:

```bash
go test ./... -race
```

1. Commit all changes:

```bash
git add internal/exporter/client.go internal/exporter/prometheus.go main.go \
        internal/exporter/client_test.go internal/telemetry/manager.go
git commit -m "feat(03-02): inject TracerProvider via options pattern

Implements TD-02: eliminate global OpenTelemetry state.

- Add ClientOption with WithTracerProvider for NbuClient
- Add CollectorOption with WithCollectorTracerProvider for NbuCollector
- TracerProvider flows from telemetry.Manager through components
- Components use TracerWrapper internally (from 03-01)
- Remove otel.GetTracerProvider() calls from constructors
- Existing tests pass without modification

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

  </action>
  <verify>
- `go test ./... -race` all tests pass
- `git log -1 --oneline` shows new commit
- No calls to otel.GetTracerProvider() in client.go or prometheus.go constructors
  </verify>
  <done>
TracerProvider injection complete, all tests pass, no global state access in constructors.
  </done>
</task>

</tasks>

<verification>
1. NewNbuClient accepts ...ClientOption with WithTracerProvider
2. NewNbuCollector accepts ...CollectorOption with WithCollectorTracerProvider
3. No otel.GetTracerProvider() in constructor paths
4. TracerWrapper used internally for nil-safety
5. main.go injects TracerProvider from telemetry manager
6. All existing tests pass
</verification>

<success_criteria>

- Options pattern implemented for both NbuClient and NbuCollector
- TracerProvider flows from main.go -> NbuCollector -> NbuClient
- No global OpenTelemetry state access in component constructors
- Components work correctly without TracerProvider (noop default)
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-architecture-improvements/03-02-SUMMARY.md`
</output>
